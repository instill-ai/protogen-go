// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: artifact/artifact/v1alpha/file.proto

package artifactv1alpha

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// file embedding process status
type FileProcessStatus int32

const (
	// UNSPECIFIED
	FileProcessStatus_FILE_PROCESS_STATUS_UNSPECIFIED FileProcessStatus = 0
	// NOTSTARTED
	FileProcessStatus_FILE_PROCESS_STATUS_NOTSTARTED FileProcessStatus = 1
	// file is being processed (parallel architecture: conversion + summarization)
	FileProcessStatus_FILE_PROCESS_STATUS_PROCESSING FileProcessStatus = 2
	// file is chunking
	FileProcessStatus_FILE_PROCESS_STATUS_CHUNKING FileProcessStatus = 3
	// file is embedding
	FileProcessStatus_FILE_PROCESS_STATUS_EMBEDDING FileProcessStatus = 4
	// completed
	FileProcessStatus_FILE_PROCESS_STATUS_COMPLETED FileProcessStatus = 5
	// failed
	FileProcessStatus_FILE_PROCESS_STATUS_FAILED FileProcessStatus = 6
)

// Enum value maps for FileProcessStatus.
var (
	FileProcessStatus_name = map[int32]string{
		0: "FILE_PROCESS_STATUS_UNSPECIFIED",
		1: "FILE_PROCESS_STATUS_NOTSTARTED",
		2: "FILE_PROCESS_STATUS_PROCESSING",
		3: "FILE_PROCESS_STATUS_CHUNKING",
		4: "FILE_PROCESS_STATUS_EMBEDDING",
		5: "FILE_PROCESS_STATUS_COMPLETED",
		6: "FILE_PROCESS_STATUS_FAILED",
	}
	FileProcessStatus_value = map[string]int32{
		"FILE_PROCESS_STATUS_UNSPECIFIED": 0,
		"FILE_PROCESS_STATUS_NOTSTARTED":  1,
		"FILE_PROCESS_STATUS_PROCESSING":  2,
		"FILE_PROCESS_STATUS_CHUNKING":    3,
		"FILE_PROCESS_STATUS_EMBEDDING":   4,
		"FILE_PROCESS_STATUS_COMPLETED":   5,
		"FILE_PROCESS_STATUS_FAILED":      6,
	}
)

func (x FileProcessStatus) Enum() *FileProcessStatus {
	p := new(FileProcessStatus)
	*p = x
	return p
}

func (x FileProcessStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileProcessStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[0].Descriptor()
}

func (FileProcessStatus) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[0]
}

func (x FileProcessStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileProcessStatus.Descriptor instead.
func (FileProcessStatus) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0}
}

// converted file type
type ConvertedFileType int32

const (
	// unspecified
	ConvertedFileType_CONVERTED_FILE_TYPE_UNSPECIFIED ConvertedFileType = 0
	// content
	ConvertedFileType_CONVERTED_FILE_TYPE_CONTENT ConvertedFileType = 1
	// summary
	ConvertedFileType_CONVERTED_FILE_TYPE_SUMMARY ConvertedFileType = 2
	// document (standardized to PDF)
	ConvertedFileType_CONVERTED_FILE_TYPE_DOCUMENT ConvertedFileType = 3
	// image (standardized to PNG)
	ConvertedFileType_CONVERTED_FILE_TYPE_IMAGE ConvertedFileType = 4
	// audio (standardized to OGG)
	ConvertedFileType_CONVERTED_FILE_TYPE_AUDIO ConvertedFileType = 5
	// video (standardized to MP4)
	ConvertedFileType_CONVERTED_FILE_TYPE_VIDEO ConvertedFileType = 6
)

// Enum value maps for ConvertedFileType.
var (
	ConvertedFileType_name = map[int32]string{
		0: "CONVERTED_FILE_TYPE_UNSPECIFIED",
		1: "CONVERTED_FILE_TYPE_CONTENT",
		2: "CONVERTED_FILE_TYPE_SUMMARY",
		3: "CONVERTED_FILE_TYPE_DOCUMENT",
		4: "CONVERTED_FILE_TYPE_IMAGE",
		5: "CONVERTED_FILE_TYPE_AUDIO",
		6: "CONVERTED_FILE_TYPE_VIDEO",
	}
	ConvertedFileType_value = map[string]int32{
		"CONVERTED_FILE_TYPE_UNSPECIFIED": 0,
		"CONVERTED_FILE_TYPE_CONTENT":     1,
		"CONVERTED_FILE_TYPE_SUMMARY":     2,
		"CONVERTED_FILE_TYPE_DOCUMENT":    3,
		"CONVERTED_FILE_TYPE_IMAGE":       4,
		"CONVERTED_FILE_TYPE_AUDIO":       5,
		"CONVERTED_FILE_TYPE_VIDEO":       6,
	}
)

func (x ConvertedFileType) Enum() *ConvertedFileType {
	p := new(ConvertedFileType)
	*p = x
	return p
}

func (x ConvertedFileType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConvertedFileType) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[1].Descriptor()
}

func (ConvertedFileType) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[1]
}

func (x ConvertedFileType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConvertedFileType.Descriptor instead.
func (ConvertedFileType) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{1}
}

// View defines how a file is presented.
type File_View int32

const (
	// Unspecified, equivalent to BASIC.
	File_VIEW_UNSPECIFIED File_View = 0
	// Default view, only includes basic metadata.
	File_VIEW_BASIC File_View = 1
	// Full representation with all metadata.
	File_VIEW_FULL File_View = 2
	// Returns MinIO pre-signed URL to converted summary content.
	File_VIEW_SUMMARY File_View = 3
	// Returns MinIO pre-signed URL to converted markdown content.
	File_VIEW_CONTENT File_View = 4
	// Returns MinIO pre-signed URL to standardized file:
	// - Documents → PDF
	// - Images → PNG
	// - Audio → OGG
	// - Video → MP4
	File_VIEW_STANDARD_FILE_TYPE File_View = 5
	// Returns MinIO pre-signed URL to the original uploaded file.
	File_VIEW_ORIGINAL_FILE_TYPE File_View = 6
	// Returns Gemini cache resource name.
	File_VIEW_CACHE File_View = 7
)

// Enum value maps for File_View.
var (
	File_View_name = map[int32]string{
		0: "VIEW_UNSPECIFIED",
		1: "VIEW_BASIC",
		2: "VIEW_FULL",
		3: "VIEW_SUMMARY",
		4: "VIEW_CONTENT",
		5: "VIEW_STANDARD_FILE_TYPE",
		6: "VIEW_ORIGINAL_FILE_TYPE",
		7: "VIEW_CACHE",
	}
	File_View_value = map[string]int32{
		"VIEW_UNSPECIFIED":        0,
		"VIEW_BASIC":              1,
		"VIEW_FULL":               2,
		"VIEW_SUMMARY":            3,
		"VIEW_CONTENT":            4,
		"VIEW_STANDARD_FILE_TYPE": 5,
		"VIEW_ORIGINAL_FILE_TYPE": 6,
		"VIEW_CACHE":              7,
	}
)

func (x File_View) Enum() *File_View {
	p := new(File_View)
	*p = x
	return p
}

func (x File_View) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (File_View) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[2].Descriptor()
}

func (File_View) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[2]
}

func (x File_View) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use File_View.Descriptor instead.
func (File_View) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0, 0}
}

// Storage provider for file resources
type File_StorageProvider int32

const (
	// Unspecified, defaults to MinIO for backward compatibility
	File_STORAGE_PROVIDER_UNSPECIFIED File_StorageProvider = 0
	// Use MinIO as the storage backend (default)
	File_STORAGE_PROVIDER_MINIO File_StorageProvider = 1
	// Use Google Cloud Storage as the storage backend
	File_STORAGE_PROVIDER_GCS File_StorageProvider = 2
)

// Enum value maps for File_StorageProvider.
var (
	File_StorageProvider_name = map[int32]string{
		0: "STORAGE_PROVIDER_UNSPECIFIED",
		1: "STORAGE_PROVIDER_MINIO",
		2: "STORAGE_PROVIDER_GCS",
	}
	File_StorageProvider_value = map[string]int32{
		"STORAGE_PROVIDER_UNSPECIFIED": 0,
		"STORAGE_PROVIDER_MINIO":       1,
		"STORAGE_PROVIDER_GCS":         2,
	}
)

func (x File_StorageProvider) Enum() *File_StorageProvider {
	p := new(File_StorageProvider)
	*p = x
	return p
}

func (x File_StorageProvider) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (File_StorageProvider) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[3].Descriptor()
}

func (File_StorageProvider) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[3]
}

func (x File_StorageProvider) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use File_StorageProvider.Descriptor instead.
func (File_StorageProvider) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0, 1}
}

// Supported file types
type File_Type int32

const (
	// unspecified
	File_TYPE_UNSPECIFIED File_Type = 0
	// Text-based document types
	// text
	File_TYPE_TEXT File_Type = 1
	// MARKDOWN
	File_TYPE_MARKDOWN File_Type = 2
	// HTML
	File_TYPE_HTML File_Type = 3
	// CSV
	File_TYPE_CSV File_Type = 4
	// Container-based document types
	// PDF
	File_TYPE_PDF File_Type = 5
	// DOC
	File_TYPE_DOC File_Type = 6
	// DOCX
	File_TYPE_DOCX File_Type = 7
	// PPT
	File_TYPE_PPT File_Type = 8
	// PPTX
	File_TYPE_PPTX File_Type = 9
	// XLS
	File_TYPE_XLS File_Type = 10
	// XLSX
	File_TYPE_XLSX File_Type = 11
	// Image types
	// PNG
	File_TYPE_PNG File_Type = 12
	// JPEG
	File_TYPE_JPEG File_Type = 13
	// GIF
	File_TYPE_GIF File_Type = 14
	// WEBP
	File_TYPE_WEBP File_Type = 15
	// TIFF
	File_TYPE_TIFF File_Type = 16
	// BMP
	File_TYPE_BMP File_Type = 17
	// HEIC
	File_TYPE_HEIC File_Type = 18
	// HEIF
	File_TYPE_HEIF File_Type = 19
	// AVIF
	File_TYPE_AVIF File_Type = 20
	// Audio types
	// MP3
	File_TYPE_MP3 File_Type = 21
	// WAV
	File_TYPE_WAV File_Type = 22
	// AAC
	File_TYPE_AAC File_Type = 23
	// OGG
	File_TYPE_OGG File_Type = 24
	// FLAC
	File_TYPE_FLAC File_Type = 25
	// M4A
	File_TYPE_M4A File_Type = 26
	// WMA
	File_TYPE_WMA File_Type = 27
	// AIFF
	File_TYPE_AIFF File_Type = 28
	// WEBM (audio)
	File_TYPE_WEBM_AUDIO File_Type = 29
	// Video types
	// MP4
	File_TYPE_MP4 File_Type = 30
	// AVI
	File_TYPE_AVI File_Type = 31
	// MOV
	File_TYPE_MOV File_Type = 32
	// MKV
	File_TYPE_MKV File_Type = 33
	// FLV
	File_TYPE_FLV File_Type = 34
	// WMV
	File_TYPE_WMV File_Type = 35
	// MPEG
	File_TYPE_MPEG File_Type = 36
	// WEBM (video)
	File_TYPE_WEBM_VIDEO File_Type = 37
)

// Enum value maps for File_Type.
var (
	File_Type_name = map[int32]string{
		0:  "TYPE_UNSPECIFIED",
		1:  "TYPE_TEXT",
		2:  "TYPE_MARKDOWN",
		3:  "TYPE_HTML",
		4:  "TYPE_CSV",
		5:  "TYPE_PDF",
		6:  "TYPE_DOC",
		7:  "TYPE_DOCX",
		8:  "TYPE_PPT",
		9:  "TYPE_PPTX",
		10: "TYPE_XLS",
		11: "TYPE_XLSX",
		12: "TYPE_PNG",
		13: "TYPE_JPEG",
		14: "TYPE_GIF",
		15: "TYPE_WEBP",
		16: "TYPE_TIFF",
		17: "TYPE_BMP",
		18: "TYPE_HEIC",
		19: "TYPE_HEIF",
		20: "TYPE_AVIF",
		21: "TYPE_MP3",
		22: "TYPE_WAV",
		23: "TYPE_AAC",
		24: "TYPE_OGG",
		25: "TYPE_FLAC",
		26: "TYPE_M4A",
		27: "TYPE_WMA",
		28: "TYPE_AIFF",
		29: "TYPE_WEBM_AUDIO",
		30: "TYPE_MP4",
		31: "TYPE_AVI",
		32: "TYPE_MOV",
		33: "TYPE_MKV",
		34: "TYPE_FLV",
		35: "TYPE_WMV",
		36: "TYPE_MPEG",
		37: "TYPE_WEBM_VIDEO",
	}
	File_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"TYPE_TEXT":        1,
		"TYPE_MARKDOWN":    2,
		"TYPE_HTML":        3,
		"TYPE_CSV":         4,
		"TYPE_PDF":         5,
		"TYPE_DOC":         6,
		"TYPE_DOCX":        7,
		"TYPE_PPT":         8,
		"TYPE_PPTX":        9,
		"TYPE_XLS":         10,
		"TYPE_XLSX":        11,
		"TYPE_PNG":         12,
		"TYPE_JPEG":        13,
		"TYPE_GIF":         14,
		"TYPE_WEBP":        15,
		"TYPE_TIFF":        16,
		"TYPE_BMP":         17,
		"TYPE_HEIC":        18,
		"TYPE_HEIF":        19,
		"TYPE_AVIF":        20,
		"TYPE_MP3":         21,
		"TYPE_WAV":         22,
		"TYPE_AAC":         23,
		"TYPE_OGG":         24,
		"TYPE_FLAC":        25,
		"TYPE_M4A":         26,
		"TYPE_WMA":         27,
		"TYPE_AIFF":        28,
		"TYPE_WEBM_AUDIO":  29,
		"TYPE_MP4":         30,
		"TYPE_AVI":         31,
		"TYPE_MOV":         32,
		"TYPE_MKV":         33,
		"TYPE_FLV":         34,
		"TYPE_WMV":         35,
		"TYPE_MPEG":        36,
		"TYPE_WEBM_VIDEO":  37,
	}
)

func (x File_Type) Enum() *File_Type {
	p := new(File_Type)
	*p = x
	return p
}

func (x File_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (File_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[4].Descriptor()
}

func (File_Type) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[4]
}

func (x File_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use File_Type.Descriptor instead.
func (File_Type) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0, 2}
}

// FileMediaType describes the media category of a knowledge base file.
type File_FileMediaType int32

const (
	// Unspecified.
	File_FILE_MEDIA_TYPE_UNSPECIFIED File_FileMediaType = 0
	// Document.
	File_FILE_MEDIA_TYPE_DOCUMENT File_FileMediaType = 1
	// Image.
	File_FILE_MEDIA_TYPE_IMAGE File_FileMediaType = 2
	// Audio.
	File_FILE_MEDIA_TYPE_AUDIO File_FileMediaType = 3
	// Video.
	File_FILE_MEDIA_TYPE_VIDEO File_FileMediaType = 4
)

// Enum value maps for File_FileMediaType.
var (
	File_FileMediaType_name = map[int32]string{
		0: "FILE_MEDIA_TYPE_UNSPECIFIED",
		1: "FILE_MEDIA_TYPE_DOCUMENT",
		2: "FILE_MEDIA_TYPE_IMAGE",
		3: "FILE_MEDIA_TYPE_AUDIO",
		4: "FILE_MEDIA_TYPE_VIDEO",
	}
	File_FileMediaType_value = map[string]int32{
		"FILE_MEDIA_TYPE_UNSPECIFIED": 0,
		"FILE_MEDIA_TYPE_DOCUMENT":    1,
		"FILE_MEDIA_TYPE_IMAGE":       2,
		"FILE_MEDIA_TYPE_AUDIO":       3,
		"FILE_MEDIA_TYPE_VIDEO":       4,
	}
)

func (x File_FileMediaType) Enum() *File_FileMediaType {
	p := new(File_FileMediaType)
	*p = x
	return p
}

func (x File_FileMediaType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (File_FileMediaType) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[5].Descriptor()
}

func (File_FileMediaType) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[5]
}

func (x File_FileMediaType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use File_FileMediaType.Descriptor instead.
func (File_FileMediaType) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0, 3}
}

// Unit of measurement for a position within a file.
type File_Position_Unit int32

const (
	// Unspecified.
	File_Position_UNIT_UNSPECIFIED File_Position_Unit = 0
	// Character positions (for Markdown and other text files).
	File_Position_UNIT_CHARACTER File_Position_Unit = 1
	// Page positions (for documents). For pages, positions are 1-indexed
	// (e.g., page 4 of 4) to align with document visualization standards.
	File_Position_UNIT_PAGE File_Position_Unit = 2
	// Time positions in milliseconds (for audio/video files).
	File_Position_UNIT_TIME_MS File_Position_Unit = 3
	// Pixel positions (for images and other 2D content).
	File_Position_UNIT_PIXEL File_Position_Unit = 4
)

// Enum value maps for File_Position_Unit.
var (
	File_Position_Unit_name = map[int32]string{
		0: "UNIT_UNSPECIFIED",
		1: "UNIT_CHARACTER",
		2: "UNIT_PAGE",
		3: "UNIT_TIME_MS",
		4: "UNIT_PIXEL",
	}
	File_Position_Unit_value = map[string]int32{
		"UNIT_UNSPECIFIED": 0,
		"UNIT_CHARACTER":   1,
		"UNIT_PAGE":        2,
		"UNIT_TIME_MS":     3,
		"UNIT_PIXEL":       4,
	}
)

func (x File_Position_Unit) Enum() *File_Position_Unit {
	p := new(File_Position_Unit)
	*p = x
	return p
}

func (x File_Position_Unit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (File_Position_Unit) Descriptor() protoreflect.EnumDescriptor {
	return file_artifact_artifact_v1alpha_file_proto_enumTypes[6].Descriptor()
}

func (File_Position_Unit) Type() protoreflect.EnumType {
	return &file_artifact_artifact_v1alpha_file_proto_enumTypes[6]
}

func (x File_Position_Unit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use File_Position_Unit.Descriptor instead.
func (File_Position_Unit) EnumDescriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0, 0, 0}
}

// File represents a file in a knowledge base.
type File struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file uid (internal UUID, also used as id).
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// The file id (same as uid).
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The resource name of the file.
	// Format: `namespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}`.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The filename provided by the user.
	Filename string `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	// file type
	Type File_Type `protobuf:"varint,5,opt,name=type,proto3,enum=artifact.artifact.v1alpha.File_Type" json:"type,omitempty"`
	// file process status
	ProcessStatus FileProcessStatus `protobuf:"varint,6,opt,name=process_status,json=processStatus,proto3,enum=artifact.artifact.v1alpha.FileProcessStatus" json:"process_status,omitempty"`
	// file process message
	ProcessOutcome string `protobuf:"bytes,7,opt,name=process_outcome,json=processOutcome,proto3" json:"process_outcome,omitempty"`
	// retrievable(this is reserved for future use)
	Retrievable bool `protobuf:"varint,8,opt,name=retrievable,proto3" json:"retrievable,omitempty"`
	// content(this is reserved for future use)
	Content string `protobuf:"bytes,9,opt,name=content,proto3" json:"content,omitempty"`
	// owner/namespace uid
	OwnerUid string `protobuf:"bytes,10,opt,name=owner_uid,json=ownerUid,proto3" json:"owner_uid,omitempty"`
	// creator uid from authn token
	CreatorUid string `protobuf:"bytes,11,opt,name=creator_uid,json=creatorUid,proto3" json:"creator_uid,omitempty"`
	// knowledge base uid
	KnowledgeBaseUid string `protobuf:"bytes,12,opt,name=knowledge_base_uid,json=knowledgeBaseUid,proto3" json:"knowledge_base_uid,omitempty"`
	// create time
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// update time
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// delete time
	DeleteTime *timestamppb.Timestamp `protobuf:"bytes,15,opt,name=delete_time,json=deleteTime,proto3" json:"delete_time,omitempty"`
	// file size in bytes
	Size int64 `protobuf:"varint,16,opt,name=size,proto3" json:"size,omitempty"`
	// total chunks
	TotalChunks int32 `protobuf:"varint,17,opt,name=total_chunks,json=totalChunks,proto3" json:"total_chunks,omitempty"`
	// total tokens
	TotalTokens int32 `protobuf:"varint,18,opt,name=total_tokens,json=totalTokens,proto3" json:"total_tokens,omitempty"`
	// Custom metadata provided by the user during file upload
	ExternalMetadata *structpb.Struct `protobuf:"bytes,19,opt,name=external_metadata,json=externalMetadata,proto3,oneof" json:"external_metadata,omitempty"`
	// Object UID referencing a file already uploaded to blob storage.
	// Two upload approaches are supported:
	//  1. Direct upload: Upload file directly to MinIO via GetObjectUploadURL, then provide the object_uid here.
	//     This avoids base64 encoding overhead and is preferred for large files.
	//  2. Inline content: Provide base64-encoded file content in the 'content' field (field 9).
	//     The system will handle the blob storage upload internally.
	//
	// When object_uid is provided, the 'content' field is ignored.
	ObjectUid string `protobuf:"bytes,20,opt,name=object_uid,json=objectUid,proto3" json:"object_uid,omitempty"`
	// Summary of the file.
	// Deprecated: Use GetFile with VIEW_SUMMARY to retrieve file summaries.
	// This field now returns an empty string as summaries are stored separately in MinIO.
	//
	// Deprecated: Marked as deprecated in artifact/artifact/v1alpha/file.proto.
	Summary string `protobuf:"bytes,21,opt,name=summary,proto3" json:"summary,omitempty"`
	// download url of the file
	DownloadUrl string `protobuf:"bytes,22,opt,name=download_url,json=downloadUrl,proto3" json:"download_url,omitempty"`
	// Pipeline used for converting the file to Markdown if the file is a
	// document (i.e., a file with pdf, doc[x] or ppt[x] extension). The value
	// identifies the pipeline release and and MUST have the format
	// `{namespaceID}/{pipelineID}@{version}`.
	// The pipeline recipe MUST have the following variable and output fields:
	// ```yaml variable
	// variable:
	//
	//	document_input:
	//	  title: document-input
	//	  description: Upload a document (PDF/DOCX/DOC/PPTX/PPT)
	//	  type: file
	//
	// ```
	// The `convert_result` output should be a list of strings, one per page.
	// ```yaml output
	// output:
	//
	//	convert_result:
	//	  title: convert-result
	//	  value: ${merge-markdown-refinement.output.results[0]}
	//
	// ```
	// Other variable and output fields will be ignored.
	//
	// The pipeline will be executed first, falling back to the knowledge base's
	// conversion pipelines if the conversion doesn't yield a non-empty result
	// (see the knowledge base creation endpoint documentation).
	//
	// For non-document knowledge base files, the conversion pipeline is deterministic
	// (such files are typically trivial to convert and don't require a dedicated
	// pipeline to improve the conversion performance).
	ConvertingPipeline *string `protobuf:"bytes,23,opt,name=converting_pipeline,json=convertingPipeline,proto3,oneof" json:"converting_pipeline,omitempty"`
	// Length of the file in the specified unit type. It is defined as the number
	// of positions (the unit will depend on the file type) that can be accessed
	// in the file.
	Length *File_Position `protobuf:"bytes,24,opt,name=length,proto3" json:"length,omitempty"`
	// Array of tags associated with the file
	Tags          []string `protobuf:"bytes,25,rep,name=tags,proto3" json:"tags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *File) Reset() {
	*x = File{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*File) ProtoMessage() {}

func (x *File) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0}
}

func (x *File) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *File) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *File) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *File) GetFilename() string {
	if x != nil {
		return x.Filename
	}
	return ""
}

func (x *File) GetType() File_Type {
	if x != nil {
		return x.Type
	}
	return File_TYPE_UNSPECIFIED
}

func (x *File) GetProcessStatus() FileProcessStatus {
	if x != nil {
		return x.ProcessStatus
	}
	return FileProcessStatus_FILE_PROCESS_STATUS_UNSPECIFIED
}

func (x *File) GetProcessOutcome() string {
	if x != nil {
		return x.ProcessOutcome
	}
	return ""
}

func (x *File) GetRetrievable() bool {
	if x != nil {
		return x.Retrievable
	}
	return false
}

func (x *File) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *File) GetOwnerUid() string {
	if x != nil {
		return x.OwnerUid
	}
	return ""
}

func (x *File) GetCreatorUid() string {
	if x != nil {
		return x.CreatorUid
	}
	return ""
}

func (x *File) GetKnowledgeBaseUid() string {
	if x != nil {
		return x.KnowledgeBaseUid
	}
	return ""
}

func (x *File) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *File) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *File) GetDeleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.DeleteTime
	}
	return nil
}

func (x *File) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *File) GetTotalChunks() int32 {
	if x != nil {
		return x.TotalChunks
	}
	return 0
}

func (x *File) GetTotalTokens() int32 {
	if x != nil {
		return x.TotalTokens
	}
	return 0
}

func (x *File) GetExternalMetadata() *structpb.Struct {
	if x != nil {
		return x.ExternalMetadata
	}
	return nil
}

func (x *File) GetObjectUid() string {
	if x != nil {
		return x.ObjectUid
	}
	return ""
}

// Deprecated: Marked as deprecated in artifact/artifact/v1alpha/file.proto.
func (x *File) GetSummary() string {
	if x != nil {
		return x.Summary
	}
	return ""
}

func (x *File) GetDownloadUrl() string {
	if x != nil {
		return x.DownloadUrl
	}
	return ""
}

func (x *File) GetConvertingPipeline() string {
	if x != nil && x.ConvertingPipeline != nil {
		return *x.ConvertingPipeline
	}
	return ""
}

func (x *File) GetLength() *File_Position {
	if x != nil {
		return x.Length
	}
	return nil
}

func (x *File) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

// CreateFileRequest represents a request to create a file.
type CreateFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// owner/namespace id
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// knowledge base id
	KnowledgeBaseId string `protobuf:"bytes,2,opt,name=knowledge_base_id,json=knowledgeBaseId,proto3" json:"knowledge_base_id,omitempty"`
	// file
	File          *File `protobuf:"bytes,3,opt,name=file,proto3" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateFileRequest) Reset() {
	*x = CreateFileRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateFileRequest) ProtoMessage() {}

func (x *CreateFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateFileRequest.ProtoReflect.Descriptor instead.
func (*CreateFileRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{1}
}

func (x *CreateFileRequest) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *CreateFileRequest) GetKnowledgeBaseId() string {
	if x != nil {
		return x.KnowledgeBaseId
	}
	return ""
}

func (x *CreateFileRequest) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

// CreateFileResponse represents a response for creating a file.
type CreateFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// file
	File          *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateFileResponse) Reset() {
	*x = CreateFileResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateFileResponse) ProtoMessage() {}

func (x *CreateFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateFileResponse.ProtoReflect.Descriptor instead.
func (*CreateFileResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{2}
}

func (x *CreateFileResponse) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

// DeleteFileRequest represents a request to delete a file.
type DeleteFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The namespace id.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// The knowledge base id.
	KnowledgeBaseId string `protobuf:"bytes,2,opt,name=knowledge_base_id,json=knowledgeBaseId,proto3" json:"knowledge_base_id,omitempty"`
	// The file id.
	FileId        string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileRequest) Reset() {
	*x = DeleteFileRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileRequest) ProtoMessage() {}

func (x *DeleteFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileRequest.ProtoReflect.Descriptor instead.
func (*DeleteFileRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{3}
}

func (x *DeleteFileRequest) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *DeleteFileRequest) GetKnowledgeBaseId() string {
	if x != nil {
		return x.KnowledgeBaseId
	}
	return ""
}

func (x *DeleteFileRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

// DeleteFileResponse represents a response for deleting a file.
type DeleteFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file id.
	FileId        string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileResponse) Reset() {
	*x = DeleteFileResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileResponse) ProtoMessage() {}

func (x *DeleteFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileResponse.ProtoReflect.Descriptor instead.
func (*DeleteFileResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{4}
}

func (x *DeleteFileResponse) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

// DeleteFileAdminRequest represents a request to delete a file (admin only).
type DeleteFileAdminRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file id.
	FileId        string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileAdminRequest) Reset() {
	*x = DeleteFileAdminRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileAdminRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileAdminRequest) ProtoMessage() {}

func (x *DeleteFileAdminRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileAdminRequest.ProtoReflect.Descriptor instead.
func (*DeleteFileAdminRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{5}
}

func (x *DeleteFileAdminRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

// DeleteFileAdminResponse represents a response for deleting a file (admin only).
type DeleteFileAdminResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file id.
	FileId        string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileAdminResponse) Reset() {
	*x = DeleteFileAdminResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileAdminResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileAdminResponse) ProtoMessage() {}

func (x *DeleteFileAdminResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileAdminResponse.ProtoReflect.Descriptor instead.
func (*DeleteFileAdminResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{6}
}

func (x *DeleteFileAdminResponse) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

// ListFilesRequest represents a request to list files.
type ListFilesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The owner/namespace id.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// The knowledge base id.
	KnowledgeBaseId string `protobuf:"bytes,2,opt,name=knowledge_base_id,json=knowledgeBaseId,proto3" json:"knowledge_base_id,omitempty"`
	// The page size (default:10; max 100).
	PageSize *int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3,oneof" json:"page_size,omitempty"`
	// The next page token(default from first file's token).
	PageToken *string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3,oneof" json:"page_token,omitempty"`
	// Filter can hold an [AIP-160](https://google.aip.dev/160)-compliant filter expression.
	// - `id="<uuid>"` or `uid="<uuid>"` - Filter by specific file ID/UID (supports multiple IDs separated by OR)
	// - `process_status="FILE_PROCESS_STATUS_COMPLETED"` - Filter by processing status
	//
	// **Examples**:
	// - List specific files: `id="uuid1" OR id="uuid2"`
	// - List completed files: `process_status="FILE_PROCESS_STATUS_COMPLETED"`
	Filter        *string `protobuf:"bytes,5,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesRequest) Reset() {
	*x = ListFilesRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesRequest) ProtoMessage() {}

func (x *ListFilesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesRequest.ProtoReflect.Descriptor instead.
func (*ListFilesRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{7}
}

func (x *ListFilesRequest) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *ListFilesRequest) GetKnowledgeBaseId() string {
	if x != nil {
		return x.KnowledgeBaseId
	}
	return ""
}

func (x *ListFilesRequest) GetPageSize() int32 {
	if x != nil && x.PageSize != nil {
		return *x.PageSize
	}
	return 0
}

func (x *ListFilesRequest) GetPageToken() string {
	if x != nil && x.PageToken != nil {
		return *x.PageToken
	}
	return ""
}

func (x *ListFilesRequest) GetFilter() string {
	if x != nil && x.Filter != nil {
		return *x.Filter
	}
	return ""
}

// ListFilesResponse represents a response for listing files.
type ListFilesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of files.
	Files []*File `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	// The total number of files.
	TotalSize int32 `protobuf:"varint,2,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// The requested page size.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// next page token
	NextPageToken string `protobuf:"bytes,4,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesResponse) Reset() {
	*x = ListFilesResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesResponse) ProtoMessage() {}

func (x *ListFilesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesResponse.ProtoReflect.Descriptor instead.
func (*ListFilesResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{8}
}

func (x *ListFilesResponse) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *ListFilesResponse) GetTotalSize() int32 {
	if x != nil {
		return x.TotalSize
	}
	return 0
}

func (x *ListFilesResponse) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListFilesResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

// GetFileRequest represents a request to get a file.
type GetFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The namespace id.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// The knowledge base id.
	KnowledgeBaseId string `protobuf:"bytes,2,opt,name=knowledge_base_id,json=knowledgeBaseId,proto3" json:"knowledge_base_id,omitempty"`
	// The file id.
	FileId string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// View allows clients to specify the desired file view in the response.
	View *File_View `protobuf:"varint,4,opt,name=view,proto3,enum=artifact.artifact.v1alpha.File_View,oneof" json:"view,omitempty"`
	// Storage provider specifies which storage backend to use for the file resource.
	// This field is only applicable for views that return file content:
	// VIEW_SUMMARY, VIEW_CONTENT, VIEW_STANDARD_FILE_TYPE, VIEW_ORIGINAL_FILE_TYPE.
	// - STORAGE_PROVIDER_UNSPECIFIED or STORAGE_PROVIDER_MINIO: Returns MinIO pre-signed URL (default)
	// - STORAGE_PROVIDER_GCS: Uploads file to GCS if not present (with cache check), returns GCS signed URL
	// GCS requires proper configuration in system settings.
	StorageProvider *File_StorageProvider `protobuf:"varint,5,opt,name=storage_provider,json=storageProvider,proto3,enum=artifact.artifact.v1alpha.File_StorageProvider,oneof" json:"storage_provider,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetFileRequest) Reset() {
	*x = GetFileRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileRequest) ProtoMessage() {}

func (x *GetFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileRequest.ProtoReflect.Descriptor instead.
func (*GetFileRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{9}
}

func (x *GetFileRequest) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *GetFileRequest) GetKnowledgeBaseId() string {
	if x != nil {
		return x.KnowledgeBaseId
	}
	return ""
}

func (x *GetFileRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *GetFileRequest) GetView() File_View {
	if x != nil && x.View != nil {
		return *x.View
	}
	return File_VIEW_UNSPECIFIED
}

func (x *GetFileRequest) GetStorageProvider() File_StorageProvider {
	if x != nil && x.StorageProvider != nil {
		return *x.StorageProvider
	}
	return File_STORAGE_PROVIDER_UNSPECIFIED
}

// GetFileResponse represents a response for getting a file.
type GetFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file metadata (always included).
	File *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// Derived resource URI based on view and storage provider:
	// - VIEW_SUMMARY/CONTENT/STANDARD_FILE_TYPE/ORIGINAL_FILE_TYPE:
	//   - STORAGE_PROVIDER_MINIO (default): MinIO pre-signed URL
	//   - STORAGE_PROVIDER_GCS: GCS signed URL (file uploaded to GCS if needed)
	//
	// - VIEW_CACHE: Gemini/VertexAI cache resource name (format: cacheContent/<cacheId>)
	// Only populated for views that return file content.
	DerivedResourceUri *string `protobuf:"bytes,2,opt,name=derived_resource_uri,json=derivedResourceUri,proto3,oneof" json:"derived_resource_uri,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GetFileResponse) Reset() {
	*x = GetFileResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileResponse) ProtoMessage() {}

func (x *GetFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileResponse.ProtoReflect.Descriptor instead.
func (*GetFileResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{10}
}

func (x *GetFileResponse) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

func (x *GetFileResponse) GetDerivedResourceUri() string {
	if x != nil && x.DerivedResourceUri != nil {
		return *x.DerivedResourceUri
	}
	return ""
}

// UpdateFileRequest represents a request to update a file.
type UpdateFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Namespace ID.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// Knowledge Base ID.
	KnowledgeBaseId string `protobuf:"bytes,2,opt,name=knowledge_base_id,json=knowledgeBaseId,proto3" json:"knowledge_base_id,omitempty"`
	// File ID.
	FileId string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// The file fields that will replace the existing ones.
	File *File `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	// The update mask specifies the subset of fields that should be modified.
	//
	// For more information about this field, see
	// https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#field-mask.
	UpdateMask    *fieldmaskpb.FieldMask `protobuf:"bytes,5,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateFileRequest) Reset() {
	*x = UpdateFileRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateFileRequest) ProtoMessage() {}

func (x *UpdateFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateFileRequest.ProtoReflect.Descriptor instead.
func (*UpdateFileRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{11}
}

func (x *UpdateFileRequest) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *UpdateFileRequest) GetKnowledgeBaseId() string {
	if x != nil {
		return x.KnowledgeBaseId
	}
	return ""
}

func (x *UpdateFileRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *UpdateFileRequest) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

func (x *UpdateFileRequest) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

// UpdateFileResponse represents a response for updating a file.
type UpdateFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Updated file.
	File          *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateFileResponse) Reset() {
	*x = UpdateFileResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateFileResponse) ProtoMessage() {}

func (x *UpdateFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateFileResponse.ProtoReflect.Descriptor instead.
func (*UpdateFileResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{12}
}

func (x *UpdateFileResponse) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

// ReprocessFileRequest represents a request to reprocess a file.
type ReprocessFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The namespace id.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// The knowledge base id.
	KnowledgeBaseId string `protobuf:"bytes,2,opt,name=knowledge_base_id,json=knowledgeBaseId,proto3" json:"knowledge_base_id,omitempty"`
	// The file id to reprocess.
	FileId        string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReprocessFileRequest) Reset() {
	*x = ReprocessFileRequest{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReprocessFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReprocessFileRequest) ProtoMessage() {}

func (x *ReprocessFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReprocessFileRequest.ProtoReflect.Descriptor instead.
func (*ReprocessFileRequest) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{13}
}

func (x *ReprocessFileRequest) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *ReprocessFileRequest) GetKnowledgeBaseId() string {
	if x != nil {
		return x.KnowledgeBaseId
	}
	return ""
}

func (x *ReprocessFileRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

// ReprocessFileResponse represents a response for reprocessing a file.
type ReprocessFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file being reprocessed.
	File *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// Status message.
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReprocessFileResponse) Reset() {
	*x = ReprocessFileResponse{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReprocessFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReprocessFileResponse) ProtoMessage() {}

func (x *ReprocessFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReprocessFileResponse.ProtoReflect.Descriptor instead.
func (*ReprocessFileResponse) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{14}
}

func (x *ReprocessFileResponse) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

func (x *ReprocessFileResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Position within a file, as coordinates in a a specific unit. The
// number of dimensions of the coordinate depends on the unit type.
type File_Position struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unit of measurement for the position.
	Unit File_Position_Unit `protobuf:"varint,1,opt,name=unit,proto3,enum=artifact.artifact.v1alpha.File_Position_Unit" json:"unit,omitempty"`
	// Position value.
	Coordinates   []uint32 `protobuf:"varint,2,rep,packed,name=coordinates,proto3" json:"coordinates,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *File_Position) Reset() {
	*x = File_Position{}
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *File_Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*File_Position) ProtoMessage() {}

func (x *File_Position) ProtoReflect() protoreflect.Message {
	mi := &file_artifact_artifact_v1alpha_file_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use File_Position.ProtoReflect.Descriptor instead.
func (*File_Position) Descriptor() ([]byte, []int) {
	return file_artifact_artifact_v1alpha_file_proto_rawDescGZIP(), []int{0, 0}
}

func (x *File_Position) GetUnit() File_Position_Unit {
	if x != nil {
		return x.Unit
	}
	return File_Position_UNIT_UNSPECIFIED
}

func (x *File_Position) GetCoordinates() []uint32 {
	if x != nil {
		return x.Coordinates
	}
	return nil
}

var File_artifact_artifact_v1alpha_file_proto protoreflect.FileDescriptor

const file_artifact_artifact_v1alpha_file_proto_rawDesc = "" +
	"\n" +
	"$artifact/artifact/v1alpha/file.proto\x12\x19artifact.artifact.v1alpha\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.proto\x1a google/protobuf/field_mask.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xd2\x13\n" +
	"\x04File\x12\x15\n" +
	"\x03uid\x18\x01 \x01(\tB\x03\xe0A\x03R\x03uid\x12\x13\n" +
	"\x02id\x18\x02 \x01(\tB\x03\xe0A\x03R\x02id\x12\x17\n" +
	"\x04name\x18\x03 \x01(\tB\x03\xe0A\x03R\x04name\x12\x1f\n" +
	"\bfilename\x18\x04 \x01(\tB\x03\xe0A\x01R\bfilename\x12=\n" +
	"\x04type\x18\x05 \x01(\x0e2$.artifact.artifact.v1alpha.File.TypeB\x03\xe0A\x01R\x04type\x12X\n" +
	"\x0eprocess_status\x18\x06 \x01(\x0e2,.artifact.artifact.v1alpha.FileProcessStatusB\x03\xe0A\x03R\rprocessStatus\x12,\n" +
	"\x0fprocess_outcome\x18\a \x01(\tB\x03\xe0A\x03R\x0eprocessOutcome\x12%\n" +
	"\vretrievable\x18\b \x01(\bB\x03\xe0A\x03R\vretrievable\x12\x1d\n" +
	"\acontent\x18\t \x01(\tB\x03\xe0A\x01R\acontent\x12 \n" +
	"\towner_uid\x18\n" +
	" \x01(\tB\x03\xe0A\x03R\bownerUid\x12$\n" +
	"\vcreator_uid\x18\v \x01(\tB\x03\xe0A\x03R\n" +
	"creatorUid\x121\n" +
	"\x12knowledge_base_uid\x18\f \x01(\tB\x03\xe0A\x03R\x10knowledgeBaseUid\x12@\n" +
	"\vcreate_time\x18\r \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"createTime\x12@\n" +
	"\vupdate_time\x18\x0e \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"updateTime\x12@\n" +
	"\vdelete_time\x18\x0f \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"deleteTime\x12\x17\n" +
	"\x04size\x18\x10 \x01(\x03B\x03\xe0A\x03R\x04size\x12&\n" +
	"\ftotal_chunks\x18\x11 \x01(\x05B\x03\xe0A\x03R\vtotalChunks\x12&\n" +
	"\ftotal_tokens\x18\x12 \x01(\x05B\x03\xe0A\x03R\vtotalTokens\x12N\n" +
	"\x11external_metadata\x18\x13 \x01(\v2\x17.google.protobuf.StructB\x03\xe0A\x01H\x00R\x10externalMetadata\x88\x01\x01\x12\"\n" +
	"\n" +
	"object_uid\x18\x14 \x01(\tB\x03\xe0A\x01R\tobjectUid\x12\x1f\n" +
	"\asummary\x18\x15 \x01(\tB\x05\xe0A\x03\x18\x01R\asummary\x12&\n" +
	"\fdownload_url\x18\x16 \x01(\tB\x03\xe0A\x03R\vdownloadUrl\x129\n" +
	"\x13converting_pipeline\x18\x17 \x01(\tB\x03\xe0A\x01H\x01R\x12convertingPipeline\x88\x01\x01\x12E\n" +
	"\x06length\x18\x18 \x01(\v2(.artifact.artifact.v1alpha.File.PositionB\x03\xe0A\x03R\x06length\x12\x17\n" +
	"\x04tags\x18\x19 \x03(\tB\x03\xe0A\x01R\x04tags\x1a\xdc\x01\n" +
	"\bPosition\x12F\n" +
	"\x04unit\x18\x01 \x01(\x0e2-.artifact.artifact.v1alpha.File.Position.UnitB\x03\xe0A\x03R\x04unit\x12%\n" +
	"\vcoordinates\x18\x02 \x03(\rB\x03\xe0A\x03R\vcoordinates\"a\n" +
	"\x04Unit\x12\x14\n" +
	"\x10UNIT_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eUNIT_CHARACTER\x10\x01\x12\r\n" +
	"\tUNIT_PAGE\x10\x02\x12\x10\n" +
	"\fUNIT_TIME_MS\x10\x03\x12\x0e\n" +
	"\n" +
	"UNIT_PIXEL\x10\x04\"\xa9\x01\n" +
	"\x04View\x12\x14\n" +
	"\x10VIEW_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"VIEW_BASIC\x10\x01\x12\r\n" +
	"\tVIEW_FULL\x10\x02\x12\x10\n" +
	"\fVIEW_SUMMARY\x10\x03\x12\x10\n" +
	"\fVIEW_CONTENT\x10\x04\x12\x1b\n" +
	"\x17VIEW_STANDARD_FILE_TYPE\x10\x05\x12\x1b\n" +
	"\x17VIEW_ORIGINAL_FILE_TYPE\x10\x06\x12\x0e\n" +
	"\n" +
	"VIEW_CACHE\x10\a\"i\n" +
	"\x0fStorageProvider\x12 \n" +
	"\x1cSTORAGE_PROVIDER_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16STORAGE_PROVIDER_MINIO\x10\x01\x12\x18\n" +
	"\x14STORAGE_PROVIDER_GCS\x10\x02\"\xc3\x04\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tTYPE_TEXT\x10\x01\x12\x11\n" +
	"\rTYPE_MARKDOWN\x10\x02\x12\r\n" +
	"\tTYPE_HTML\x10\x03\x12\f\n" +
	"\bTYPE_CSV\x10\x04\x12\f\n" +
	"\bTYPE_PDF\x10\x05\x12\f\n" +
	"\bTYPE_DOC\x10\x06\x12\r\n" +
	"\tTYPE_DOCX\x10\a\x12\f\n" +
	"\bTYPE_PPT\x10\b\x12\r\n" +
	"\tTYPE_PPTX\x10\t\x12\f\n" +
	"\bTYPE_XLS\x10\n" +
	"\x12\r\n" +
	"\tTYPE_XLSX\x10\v\x12\f\n" +
	"\bTYPE_PNG\x10\f\x12\r\n" +
	"\tTYPE_JPEG\x10\r\x12\f\n" +
	"\bTYPE_GIF\x10\x0e\x12\r\n" +
	"\tTYPE_WEBP\x10\x0f\x12\r\n" +
	"\tTYPE_TIFF\x10\x10\x12\f\n" +
	"\bTYPE_BMP\x10\x11\x12\r\n" +
	"\tTYPE_HEIC\x10\x12\x12\r\n" +
	"\tTYPE_HEIF\x10\x13\x12\r\n" +
	"\tTYPE_AVIF\x10\x14\x12\f\n" +
	"\bTYPE_MP3\x10\x15\x12\f\n" +
	"\bTYPE_WAV\x10\x16\x12\f\n" +
	"\bTYPE_AAC\x10\x17\x12\f\n" +
	"\bTYPE_OGG\x10\x18\x12\r\n" +
	"\tTYPE_FLAC\x10\x19\x12\f\n" +
	"\bTYPE_M4A\x10\x1a\x12\f\n" +
	"\bTYPE_WMA\x10\x1b\x12\r\n" +
	"\tTYPE_AIFF\x10\x1c\x12\x13\n" +
	"\x0fTYPE_WEBM_AUDIO\x10\x1d\x12\f\n" +
	"\bTYPE_MP4\x10\x1e\x12\f\n" +
	"\bTYPE_AVI\x10\x1f\x12\f\n" +
	"\bTYPE_MOV\x10 \x12\f\n" +
	"\bTYPE_MKV\x10!\x12\f\n" +
	"\bTYPE_FLV\x10\"\x12\f\n" +
	"\bTYPE_WMV\x10#\x12\r\n" +
	"\tTYPE_MPEG\x10$\x12\x13\n" +
	"\x0fTYPE_WEBM_VIDEO\x10%\"\x9f\x01\n" +
	"\rFileMediaType\x12\x1f\n" +
	"\x1bFILE_MEDIA_TYPE_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18FILE_MEDIA_TYPE_DOCUMENT\x10\x01\x12\x19\n" +
	"\x15FILE_MEDIA_TYPE_IMAGE\x10\x02\x12\x19\n" +
	"\x15FILE_MEDIA_TYPE_AUDIO\x10\x03\x12\x19\n" +
	"\x15FILE_MEDIA_TYPE_VIDEO\x10\x04:I\xeaAF\x12Dnamespaces/{namespace}/knowledge-bases/{knowledge_base}/files/{file}B\x14\n" +
	"\x12_external_metadataB\x16\n" +
	"\x14_converting_pipeline\"\xa6\x01\n" +
	"\x11CreateFileRequest\x12&\n" +
	"\fnamespace_id\x18\x01 \x01(\tB\x03\xe0A\x02R\vnamespaceId\x12/\n" +
	"\x11knowledge_base_id\x18\x02 \x01(\tB\x03\xe0A\x02R\x0fknowledgeBaseId\x128\n" +
	"\x04file\x18\x03 \x01(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x01R\x04file\"N\n" +
	"\x12CreateFileResponse\x128\n" +
	"\x04file\x18\x01 \x01(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x03R\x04file\"\x8a\x01\n" +
	"\x11DeleteFileRequest\x12&\n" +
	"\fnamespace_id\x18\x01 \x01(\tB\x03\xe0A\x02R\vnamespaceId\x12/\n" +
	"\x11knowledge_base_id\x18\x02 \x01(\tB\x03\xe0A\x02R\x0fknowledgeBaseId\x12\x1c\n" +
	"\afile_id\x18\x03 \x01(\tB\x03\xe0A\x02R\x06fileId\"2\n" +
	"\x12DeleteFileResponse\x12\x1c\n" +
	"\afile_id\x18\x01 \x01(\tB\x03\xe0A\x03R\x06fileId\"6\n" +
	"\x16DeleteFileAdminRequest\x12\x1c\n" +
	"\afile_id\x18\x01 \x01(\tB\x03\xe0A\x02R\x06fileId\"7\n" +
	"\x17DeleteFileAdminResponse\x12\x1c\n" +
	"\afile_id\x18\x01 \x01(\tB\x03\xe0A\x03R\x06fileId\"\x85\x02\n" +
	"\x10ListFilesRequest\x12&\n" +
	"\fnamespace_id\x18\x01 \x01(\tB\x03\xe0A\x02R\vnamespaceId\x12/\n" +
	"\x11knowledge_base_id\x18\x02 \x01(\tB\x03\xe0A\x02R\x0fknowledgeBaseId\x12%\n" +
	"\tpage_size\x18\x03 \x01(\x05B\x03\xe0A\x01H\x00R\bpageSize\x88\x01\x01\x12'\n" +
	"\n" +
	"page_token\x18\x04 \x01(\tB\x03\xe0A\x01H\x01R\tpageToken\x88\x01\x01\x12 \n" +
	"\x06filter\x18\x05 \x01(\tB\x03\xe0A\x01H\x02R\x06filter\x88\x01\x01B\f\n" +
	"\n" +
	"_page_sizeB\r\n" +
	"\v_page_tokenB\t\n" +
	"\a_filter\"\xc2\x01\n" +
	"\x11ListFilesResponse\x12:\n" +
	"\x05files\x18\x01 \x03(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x03R\x05files\x12\"\n" +
	"\n" +
	"total_size\x18\x02 \x01(\x05B\x03\xe0A\x03R\ttotalSize\x12 \n" +
	"\tpage_size\x18\x03 \x01(\x05B\x03\xe0A\x03R\bpageSize\x12+\n" +
	"\x0fnext_page_token\x18\x04 \x01(\tB\x03\xe0A\x03R\rnextPageToken\"\xcf\x02\n" +
	"\x0eGetFileRequest\x12&\n" +
	"\fnamespace_id\x18\x01 \x01(\tB\x03\xe0A\x02R\vnamespaceId\x12/\n" +
	"\x11knowledge_base_id\x18\x02 \x01(\tB\x03\xe0A\x02R\x0fknowledgeBaseId\x12\x1c\n" +
	"\afile_id\x18\x03 \x01(\tB\x03\xe0A\x02R\x06fileId\x12B\n" +
	"\x04view\x18\x04 \x01(\x0e2$.artifact.artifact.v1alpha.File.ViewB\x03\xe0A\x01H\x00R\x04view\x88\x01\x01\x12d\n" +
	"\x10storage_provider\x18\x05 \x01(\x0e2/.artifact.artifact.v1alpha.File.StorageProviderB\x03\xe0A\x01H\x01R\x0fstorageProvider\x88\x01\x01B\a\n" +
	"\x05_viewB\x13\n" +
	"\x11_storage_provider\"\xa0\x01\n" +
	"\x0fGetFileResponse\x128\n" +
	"\x04file\x18\x01 \x01(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x03R\x04file\x12:\n" +
	"\x14derived_resource_uri\x18\x02 \x01(\tB\x03\xe0A\x03H\x00R\x12derivedResourceUri\x88\x01\x01B\x17\n" +
	"\x15_derived_resource_uri\"\x86\x02\n" +
	"\x11UpdateFileRequest\x12&\n" +
	"\fnamespace_id\x18\x01 \x01(\tB\x03\xe0A\x02R\vnamespaceId\x12/\n" +
	"\x11knowledge_base_id\x18\x02 \x01(\tB\x03\xe0A\x02R\x0fknowledgeBaseId\x12\x1c\n" +
	"\afile_id\x18\x03 \x01(\tB\x03\xe0A\x02R\x06fileId\x128\n" +
	"\x04file\x18\x04 \x01(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x01R\x04file\x12@\n" +
	"\vupdate_mask\x18\x05 \x01(\v2\x1a.google.protobuf.FieldMaskB\x03\xe0A\x02R\n" +
	"updateMask\"N\n" +
	"\x12UpdateFileResponse\x128\n" +
	"\x04file\x18\x01 \x01(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x03R\x04file\"\x8d\x01\n" +
	"\x14ReprocessFileRequest\x12&\n" +
	"\fnamespace_id\x18\x01 \x01(\tB\x03\xe0A\x02R\vnamespaceId\x12/\n" +
	"\x11knowledge_base_id\x18\x02 \x01(\tB\x03\xe0A\x02R\x0fknowledgeBaseId\x12\x1c\n" +
	"\afile_id\x18\x03 \x01(\tB\x03\xe0A\x02R\x06fileId\"p\n" +
	"\x15ReprocessFileResponse\x128\n" +
	"\x04file\x18\x01 \x01(\v2\x1f.artifact.artifact.v1alpha.FileB\x03\xe0A\x03R\x04file\x12\x1d\n" +
	"\amessage\x18\x02 \x01(\tB\x03\xe0A\x03R\amessage*\x88\x02\n" +
	"\x11FileProcessStatus\x12#\n" +
	"\x1fFILE_PROCESS_STATUS_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eFILE_PROCESS_STATUS_NOTSTARTED\x10\x01\x12\"\n" +
	"\x1eFILE_PROCESS_STATUS_PROCESSING\x10\x02\x12 \n" +
	"\x1cFILE_PROCESS_STATUS_CHUNKING\x10\x03\x12!\n" +
	"\x1dFILE_PROCESS_STATUS_EMBEDDING\x10\x04\x12!\n" +
	"\x1dFILE_PROCESS_STATUS_COMPLETED\x10\x05\x12\x1e\n" +
	"\x1aFILE_PROCESS_STATUS_FAILED\x10\x06*\xf9\x01\n" +
	"\x11ConvertedFileType\x12#\n" +
	"\x1fCONVERTED_FILE_TYPE_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bCONVERTED_FILE_TYPE_CONTENT\x10\x01\x12\x1f\n" +
	"\x1bCONVERTED_FILE_TYPE_SUMMARY\x10\x02\x12 \n" +
	"\x1cCONVERTED_FILE_TYPE_DOCUMENT\x10\x03\x12\x1d\n" +
	"\x19CONVERTED_FILE_TYPE_IMAGE\x10\x04\x12\x1d\n" +
	"\x19CONVERTED_FILE_TYPE_AUDIO\x10\x05\x12\x1d\n" +
	"\x19CONVERTED_FILE_TYPE_VIDEO\x10\x06B\xfd\x01\n" +
	"\x1dcom.artifact.artifact.v1alphaB\tFileProtoP\x01ZKgithub.com/instill-ai/protogen-go/artifact/artifact/v1alpha;artifactv1alpha\xa2\x02\x03AAX\xaa\x02\x19Artifact.Artifact.V1alpha\xca\x02\x19Artifact\\Artifact\\V1alpha\xe2\x02%Artifact\\Artifact\\V1alpha\\GPBMetadata\xea\x02\x1bArtifact::Artifact::V1alphab\x06proto3"

var (
	file_artifact_artifact_v1alpha_file_proto_rawDescOnce sync.Once
	file_artifact_artifact_v1alpha_file_proto_rawDescData []byte
)

func file_artifact_artifact_v1alpha_file_proto_rawDescGZIP() []byte {
	file_artifact_artifact_v1alpha_file_proto_rawDescOnce.Do(func() {
		file_artifact_artifact_v1alpha_file_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_artifact_artifact_v1alpha_file_proto_rawDesc), len(file_artifact_artifact_v1alpha_file_proto_rawDesc)))
	})
	return file_artifact_artifact_v1alpha_file_proto_rawDescData
}

var file_artifact_artifact_v1alpha_file_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_artifact_artifact_v1alpha_file_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_artifact_artifact_v1alpha_file_proto_goTypes = []any{
	(FileProcessStatus)(0),          // 0: artifact.artifact.v1alpha.FileProcessStatus
	(ConvertedFileType)(0),          // 1: artifact.artifact.v1alpha.ConvertedFileType
	(File_View)(0),                  // 2: artifact.artifact.v1alpha.File.View
	(File_StorageProvider)(0),       // 3: artifact.artifact.v1alpha.File.StorageProvider
	(File_Type)(0),                  // 4: artifact.artifact.v1alpha.File.Type
	(File_FileMediaType)(0),         // 5: artifact.artifact.v1alpha.File.FileMediaType
	(File_Position_Unit)(0),         // 6: artifact.artifact.v1alpha.File.Position.Unit
	(*File)(nil),                    // 7: artifact.artifact.v1alpha.File
	(*CreateFileRequest)(nil),       // 8: artifact.artifact.v1alpha.CreateFileRequest
	(*CreateFileResponse)(nil),      // 9: artifact.artifact.v1alpha.CreateFileResponse
	(*DeleteFileRequest)(nil),       // 10: artifact.artifact.v1alpha.DeleteFileRequest
	(*DeleteFileResponse)(nil),      // 11: artifact.artifact.v1alpha.DeleteFileResponse
	(*DeleteFileAdminRequest)(nil),  // 12: artifact.artifact.v1alpha.DeleteFileAdminRequest
	(*DeleteFileAdminResponse)(nil), // 13: artifact.artifact.v1alpha.DeleteFileAdminResponse
	(*ListFilesRequest)(nil),        // 14: artifact.artifact.v1alpha.ListFilesRequest
	(*ListFilesResponse)(nil),       // 15: artifact.artifact.v1alpha.ListFilesResponse
	(*GetFileRequest)(nil),          // 16: artifact.artifact.v1alpha.GetFileRequest
	(*GetFileResponse)(nil),         // 17: artifact.artifact.v1alpha.GetFileResponse
	(*UpdateFileRequest)(nil),       // 18: artifact.artifact.v1alpha.UpdateFileRequest
	(*UpdateFileResponse)(nil),      // 19: artifact.artifact.v1alpha.UpdateFileResponse
	(*ReprocessFileRequest)(nil),    // 20: artifact.artifact.v1alpha.ReprocessFileRequest
	(*ReprocessFileResponse)(nil),   // 21: artifact.artifact.v1alpha.ReprocessFileResponse
	(*File_Position)(nil),           // 22: artifact.artifact.v1alpha.File.Position
	(*timestamppb.Timestamp)(nil),   // 23: google.protobuf.Timestamp
	(*structpb.Struct)(nil),         // 24: google.protobuf.Struct
	(*fieldmaskpb.FieldMask)(nil),   // 25: google.protobuf.FieldMask
}
var file_artifact_artifact_v1alpha_file_proto_depIdxs = []int32{
	4,  // 0: artifact.artifact.v1alpha.File.type:type_name -> artifact.artifact.v1alpha.File.Type
	0,  // 1: artifact.artifact.v1alpha.File.process_status:type_name -> artifact.artifact.v1alpha.FileProcessStatus
	23, // 2: artifact.artifact.v1alpha.File.create_time:type_name -> google.protobuf.Timestamp
	23, // 3: artifact.artifact.v1alpha.File.update_time:type_name -> google.protobuf.Timestamp
	23, // 4: artifact.artifact.v1alpha.File.delete_time:type_name -> google.protobuf.Timestamp
	24, // 5: artifact.artifact.v1alpha.File.external_metadata:type_name -> google.protobuf.Struct
	22, // 6: artifact.artifact.v1alpha.File.length:type_name -> artifact.artifact.v1alpha.File.Position
	7,  // 7: artifact.artifact.v1alpha.CreateFileRequest.file:type_name -> artifact.artifact.v1alpha.File
	7,  // 8: artifact.artifact.v1alpha.CreateFileResponse.file:type_name -> artifact.artifact.v1alpha.File
	7,  // 9: artifact.artifact.v1alpha.ListFilesResponse.files:type_name -> artifact.artifact.v1alpha.File
	2,  // 10: artifact.artifact.v1alpha.GetFileRequest.view:type_name -> artifact.artifact.v1alpha.File.View
	3,  // 11: artifact.artifact.v1alpha.GetFileRequest.storage_provider:type_name -> artifact.artifact.v1alpha.File.StorageProvider
	7,  // 12: artifact.artifact.v1alpha.GetFileResponse.file:type_name -> artifact.artifact.v1alpha.File
	7,  // 13: artifact.artifact.v1alpha.UpdateFileRequest.file:type_name -> artifact.artifact.v1alpha.File
	25, // 14: artifact.artifact.v1alpha.UpdateFileRequest.update_mask:type_name -> google.protobuf.FieldMask
	7,  // 15: artifact.artifact.v1alpha.UpdateFileResponse.file:type_name -> artifact.artifact.v1alpha.File
	7,  // 16: artifact.artifact.v1alpha.ReprocessFileResponse.file:type_name -> artifact.artifact.v1alpha.File
	6,  // 17: artifact.artifact.v1alpha.File.Position.unit:type_name -> artifact.artifact.v1alpha.File.Position.Unit
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_artifact_artifact_v1alpha_file_proto_init() }
func file_artifact_artifact_v1alpha_file_proto_init() {
	if File_artifact_artifact_v1alpha_file_proto != nil {
		return
	}
	file_artifact_artifact_v1alpha_file_proto_msgTypes[0].OneofWrappers = []any{}
	file_artifact_artifact_v1alpha_file_proto_msgTypes[7].OneofWrappers = []any{}
	file_artifact_artifact_v1alpha_file_proto_msgTypes[9].OneofWrappers = []any{}
	file_artifact_artifact_v1alpha_file_proto_msgTypes[10].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_artifact_artifact_v1alpha_file_proto_rawDesc), len(file_artifact_artifact_v1alpha_file_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_artifact_artifact_v1alpha_file_proto_goTypes,
		DependencyIndexes: file_artifact_artifact_v1alpha_file_proto_depIdxs,
		EnumInfos:         file_artifact_artifact_v1alpha_file_proto_enumTypes,
		MessageInfos:      file_artifact_artifact_v1alpha_file_proto_msgTypes,
	}.Build()
	File_artifact_artifact_v1alpha_file_proto = out.File
	file_artifact_artifact_v1alpha_file_proto_goTypes = nil
	file_artifact_artifact_v1alpha_file_proto_depIdxs = nil
}
