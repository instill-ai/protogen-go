// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: artifact/artifact/v1alpha/artifact.proto

package artifactv1alpha

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	runv1alpha "github.com/instill-ai/protogen-go/common/run/v1alpha"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = runv1alpha.RunStatus(0)
)

// Validate checks the field values on LivenessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LivenessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LivenessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LivenessRequestMultiError, or nil if none found.
func (m *LivenessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LivenessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.HealthCheckRequest != nil {

		if all {
			switch v := interface{}(m.GetHealthCheckRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LivenessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LivenessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHealthCheckRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LivenessRequestValidationError{
					field:  "HealthCheckRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LivenessRequestMultiError(errors)
	}

	return nil
}

// LivenessRequestMultiError is an error wrapping multiple validation errors
// returned by LivenessRequest.ValidateAll() if the designated constraints
// aren't met.
type LivenessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LivenessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LivenessRequestMultiError) AllErrors() []error { return m }

// LivenessRequestValidationError is the validation error returned by
// LivenessRequest.Validate if the designated constraints aren't met.
type LivenessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LivenessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LivenessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LivenessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LivenessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LivenessRequestValidationError) ErrorName() string { return "LivenessRequestValidationError" }

// Error satisfies the builtin error interface
func (e LivenessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLivenessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LivenessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LivenessRequestValidationError{}

// Validate checks the field values on LivenessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LivenessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LivenessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LivenessResponseMultiError, or nil if none found.
func (m *LivenessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LivenessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHealthCheckResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LivenessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LivenessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthCheckResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LivenessResponseValidationError{
				field:  "HealthCheckResponse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LivenessResponseMultiError(errors)
	}

	return nil
}

// LivenessResponseMultiError is an error wrapping multiple validation errors
// returned by LivenessResponse.ValidateAll() if the designated constraints
// aren't met.
type LivenessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LivenessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LivenessResponseMultiError) AllErrors() []error { return m }

// LivenessResponseValidationError is the validation error returned by
// LivenessResponse.Validate if the designated constraints aren't met.
type LivenessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LivenessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LivenessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LivenessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LivenessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LivenessResponseValidationError) ErrorName() string { return "LivenessResponseValidationError" }

// Error satisfies the builtin error interface
func (e LivenessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLivenessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LivenessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LivenessResponseValidationError{}

// Validate checks the field values on ReadinessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessRequestMultiError, or nil if none found.
func (m *ReadinessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.HealthCheckRequest != nil {

		if all {
			switch v := interface{}(m.GetHealthCheckRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadinessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadinessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHealthCheckRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadinessRequestValidationError{
					field:  "HealthCheckRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadinessRequestMultiError(errors)
	}

	return nil
}

// ReadinessRequestMultiError is an error wrapping multiple validation errors
// returned by ReadinessRequest.ValidateAll() if the designated constraints
// aren't met.
type ReadinessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessRequestMultiError) AllErrors() []error { return m }

// ReadinessRequestValidationError is the validation error returned by
// ReadinessRequest.Validate if the designated constraints aren't met.
type ReadinessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessRequestValidationError) ErrorName() string { return "ReadinessRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReadinessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessRequestValidationError{}

// Validate checks the field values on ReadinessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessResponseMultiError, or nil if none found.
func (m *ReadinessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHealthCheckResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadinessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadinessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthCheckResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadinessResponseValidationError{
				field:  "HealthCheckResponse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadinessResponseMultiError(errors)
	}

	return nil
}

// ReadinessResponseMultiError is an error wrapping multiple validation errors
// returned by ReadinessResponse.ValidateAll() if the designated constraints
// aren't met.
type ReadinessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessResponseMultiError) AllErrors() []error { return m }

// ReadinessResponseValidationError is the validation error returned by
// ReadinessResponse.Validate if the designated constraints aren't met.
type ReadinessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessResponseValidationError) ErrorName() string {
	return "ReadinessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadinessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessResponseValidationError{}

// Validate checks the field values on RepositoryTag with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepositoryTag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepositoryTag with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepositoryTagMultiError, or
// nil if none found.
func (m *RepositoryTag) ValidateAll() error {
	return m.validate(true)
}

func (m *RepositoryTag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	// no validation rules for Digest

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepositoryTagValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepositoryTagValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepositoryTagValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepositoryTagMultiError(errors)
	}

	return nil
}

// RepositoryTagMultiError is an error wrapping multiple validation errors
// returned by RepositoryTag.ValidateAll() if the designated constraints
// aren't met.
type RepositoryTagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepositoryTagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepositoryTagMultiError) AllErrors() []error { return m }

// RepositoryTagValidationError is the validation error returned by
// RepositoryTag.Validate if the designated constraints aren't met.
type RepositoryTagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepositoryTagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepositoryTagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepositoryTagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepositoryTagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepositoryTagValidationError) ErrorName() string { return "RepositoryTagValidationError" }

// Error satisfies the builtin error interface
func (e RepositoryTagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepositoryTag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepositoryTagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepositoryTagValidationError{}

// Validate checks the field values on ListRepositoryTagsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryTagsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryTagsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryTagsRequestMultiError, or nil if none found.
func (m *ListRepositoryTagsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryTagsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if len(errors) > 0 {
		return ListRepositoryTagsRequestMultiError(errors)
	}

	return nil
}

// ListRepositoryTagsRequestMultiError is an error wrapping multiple validation
// errors returned by ListRepositoryTagsRequest.ValidateAll() if the
// designated constraints aren't met.
type ListRepositoryTagsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryTagsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryTagsRequestMultiError) AllErrors() []error { return m }

// ListRepositoryTagsRequestValidationError is the validation error returned by
// ListRepositoryTagsRequest.Validate if the designated constraints aren't met.
type ListRepositoryTagsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryTagsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryTagsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryTagsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryTagsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryTagsRequestValidationError) ErrorName() string {
	return "ListRepositoryTagsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryTagsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryTagsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryTagsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryTagsRequestValidationError{}

// Validate checks the field values on ListRepositoryTagsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryTagsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryTagsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryTagsResponseMultiError, or nil if none found.
func (m *ListRepositoryTagsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryTagsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRepositoryTagsResponseValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRepositoryTagsResponseValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRepositoryTagsResponseValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalSize

	// no validation rules for PageSize

	// no validation rules for Page

	if len(errors) > 0 {
		return ListRepositoryTagsResponseMultiError(errors)
	}

	return nil
}

// ListRepositoryTagsResponseMultiError is an error wrapping multiple
// validation errors returned by ListRepositoryTagsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListRepositoryTagsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryTagsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryTagsResponseMultiError) AllErrors() []error { return m }

// ListRepositoryTagsResponseValidationError is the validation error returned
// by ListRepositoryTagsResponse.Validate if the designated constraints aren't met.
type ListRepositoryTagsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryTagsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryTagsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryTagsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryTagsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryTagsResponseValidationError) ErrorName() string {
	return "ListRepositoryTagsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryTagsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryTagsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryTagsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryTagsResponseValidationError{}

// Validate checks the field values on CreateRepositoryTagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryTagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryTagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryTagRequestMultiError, or nil if none found.
func (m *CreateRepositoryTagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryTagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTag()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryTagRequestValidationError{
					field:  "Tag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryTagRequestValidationError{
					field:  "Tag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTag()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryTagRequestValidationError{
				field:  "Tag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepositoryTagRequestMultiError(errors)
	}

	return nil
}

// CreateRepositoryTagRequestMultiError is an error wrapping multiple
// validation errors returned by CreateRepositoryTagRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateRepositoryTagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryTagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryTagRequestMultiError) AllErrors() []error { return m }

// CreateRepositoryTagRequestValidationError is the validation error returned
// by CreateRepositoryTagRequest.Validate if the designated constraints aren't met.
type CreateRepositoryTagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryTagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryTagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryTagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryTagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryTagRequestValidationError) ErrorName() string {
	return "CreateRepositoryTagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryTagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryTagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryTagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryTagRequestValidationError{}

// Validate checks the field values on CreateRepositoryTagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryTagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryTagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryTagResponseMultiError, or nil if none found.
func (m *CreateRepositoryTagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryTagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTag()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryTagResponseValidationError{
					field:  "Tag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryTagResponseValidationError{
					field:  "Tag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTag()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryTagResponseValidationError{
				field:  "Tag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepositoryTagResponseMultiError(errors)
	}

	return nil
}

// CreateRepositoryTagResponseMultiError is an error wrapping multiple
// validation errors returned by CreateRepositoryTagResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateRepositoryTagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryTagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryTagResponseMultiError) AllErrors() []error { return m }

// CreateRepositoryTagResponseValidationError is the validation error returned
// by CreateRepositoryTagResponse.Validate if the designated constraints
// aren't met.
type CreateRepositoryTagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryTagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryTagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryTagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryTagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryTagResponseValidationError) ErrorName() string {
	return "CreateRepositoryTagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryTagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryTagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryTagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryTagResponseValidationError{}

// Validate checks the field values on GetRepositoryTagRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryTagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryTagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryTagRequestMultiError, or nil if none found.
func (m *GetRepositoryTagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryTagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return GetRepositoryTagRequestMultiError(errors)
	}

	return nil
}

// GetRepositoryTagRequestMultiError is an error wrapping multiple validation
// errors returned by GetRepositoryTagRequest.ValidateAll() if the designated
// constraints aren't met.
type GetRepositoryTagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryTagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryTagRequestMultiError) AllErrors() []error { return m }

// GetRepositoryTagRequestValidationError is the validation error returned by
// GetRepositoryTagRequest.Validate if the designated constraints aren't met.
type GetRepositoryTagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryTagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryTagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryTagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryTagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryTagRequestValidationError) ErrorName() string {
	return "GetRepositoryTagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryTagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryTagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryTagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryTagRequestValidationError{}

// Validate checks the field values on GetRepositoryTagResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryTagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryTagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryTagResponseMultiError, or nil if none found.
func (m *GetRepositoryTagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryTagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTag()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryTagResponseValidationError{
					field:  "Tag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryTagResponseValidationError{
					field:  "Tag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTag()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryTagResponseValidationError{
				field:  "Tag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRepositoryTagResponseMultiError(errors)
	}

	return nil
}

// GetRepositoryTagResponseMultiError is an error wrapping multiple validation
// errors returned by GetRepositoryTagResponse.ValidateAll() if the designated
// constraints aren't met.
type GetRepositoryTagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryTagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryTagResponseMultiError) AllErrors() []error { return m }

// GetRepositoryTagResponseValidationError is the validation error returned by
// GetRepositoryTagResponse.Validate if the designated constraints aren't met.
type GetRepositoryTagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryTagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryTagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryTagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryTagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryTagResponseValidationError) ErrorName() string {
	return "GetRepositoryTagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryTagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryTagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryTagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryTagResponseValidationError{}

// Validate checks the field values on DeleteRepositoryTagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryTagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryTagRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryTagRequestMultiError, or nil if none found.
func (m *DeleteRepositoryTagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryTagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return DeleteRepositoryTagRequestMultiError(errors)
	}

	return nil
}

// DeleteRepositoryTagRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteRepositoryTagRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteRepositoryTagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryTagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryTagRequestMultiError) AllErrors() []error { return m }

// DeleteRepositoryTagRequestValidationError is the validation error returned
// by DeleteRepositoryTagRequest.Validate if the designated constraints aren't met.
type DeleteRepositoryTagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryTagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryTagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryTagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryTagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryTagRequestValidationError) ErrorName() string {
	return "DeleteRepositoryTagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryTagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryTagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryTagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryTagRequestValidationError{}

// Validate checks the field values on DeleteRepositoryTagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepositoryTagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepositoryTagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepositoryTagResponseMultiError, or nil if none found.
func (m *DeleteRepositoryTagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepositoryTagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteRepositoryTagResponseMultiError(errors)
	}

	return nil
}

// DeleteRepositoryTagResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteRepositoryTagResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteRepositoryTagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepositoryTagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepositoryTagResponseMultiError) AllErrors() []error { return m }

// DeleteRepositoryTagResponseValidationError is the validation error returned
// by DeleteRepositoryTagResponse.Validate if the designated constraints
// aren't met.
type DeleteRepositoryTagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepositoryTagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepositoryTagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepositoryTagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepositoryTagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepositoryTagResponseValidationError) ErrorName() string {
	return "DeleteRepositoryTagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepositoryTagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepositoryTagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepositoryTagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepositoryTagResponseValidationError{}

// Validate checks the field values on Catalog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Catalog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Catalog with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CatalogMultiError, or nil if none found.
func (m *Catalog) ValidateAll() error {
	return m.validate(true)
}

func (m *Catalog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CatalogUid

	// no validation rules for CatalogId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for OwnerName

	// no validation rules for TotalFiles

	// no validation rules for TotalTokens

	// no validation rules for UsedStorage

	if len(errors) > 0 {
		return CatalogMultiError(errors)
	}

	return nil
}

// CatalogMultiError is an error wrapping multiple validation errors returned
// by Catalog.ValidateAll() if the designated constraints aren't met.
type CatalogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CatalogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CatalogMultiError) AllErrors() []error { return m }

// CatalogValidationError is the validation error returned by Catalog.Validate
// if the designated constraints aren't met.
type CatalogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CatalogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CatalogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CatalogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CatalogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CatalogValidationError) ErrorName() string { return "CatalogValidationError" }

// Error satisfies the builtin error interface
func (e CatalogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCatalog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CatalogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CatalogValidationError{}

// Validate checks the field values on CreateCatalogRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCatalogRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCatalogRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCatalogRequestMultiError, or nil if none found.
func (m *CreateCatalogRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCatalogRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for Name

	// no validation rules for Description

	if len(errors) > 0 {
		return CreateCatalogRequestMultiError(errors)
	}

	return nil
}

// CreateCatalogRequestMultiError is an error wrapping multiple validation
// errors returned by CreateCatalogRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateCatalogRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCatalogRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCatalogRequestMultiError) AllErrors() []error { return m }

// CreateCatalogRequestValidationError is the validation error returned by
// CreateCatalogRequest.Validate if the designated constraints aren't met.
type CreateCatalogRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCatalogRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCatalogRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCatalogRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCatalogRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCatalogRequestValidationError) ErrorName() string {
	return "CreateCatalogRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCatalogRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCatalogRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCatalogRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCatalogRequestValidationError{}

// Validate checks the field values on CreateCatalogResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCatalogResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCatalogResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCatalogResponseMultiError, or nil if none found.
func (m *CreateCatalogResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCatalogResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCatalog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCatalogResponseValidationError{
					field:  "Catalog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCatalogResponseValidationError{
					field:  "Catalog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatalog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCatalogResponseValidationError{
				field:  "Catalog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCatalogResponseMultiError(errors)
	}

	return nil
}

// CreateCatalogResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCatalogResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCatalogResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCatalogResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCatalogResponseMultiError) AllErrors() []error { return m }

// CreateCatalogResponseValidationError is the validation error returned by
// CreateCatalogResponse.Validate if the designated constraints aren't met.
type CreateCatalogResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCatalogResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCatalogResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCatalogResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCatalogResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCatalogResponseValidationError) ErrorName() string {
	return "CreateCatalogResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCatalogResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCatalogResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCatalogResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCatalogResponseValidationError{}

// Validate checks the field values on ListCatalogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogsRequestMultiError, or nil if none found.
func (m *ListCatalogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	if len(errors) > 0 {
		return ListCatalogsRequestMultiError(errors)
	}

	return nil
}

// ListCatalogsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCatalogsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogsRequestMultiError) AllErrors() []error { return m }

// ListCatalogsRequestValidationError is the validation error returned by
// ListCatalogsRequest.Validate if the designated constraints aren't met.
type ListCatalogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogsRequestValidationError) ErrorName() string {
	return "ListCatalogsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogsRequestValidationError{}

// Validate checks the field values on ListCatalogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogsResponseMultiError, or nil if none found.
func (m *ListCatalogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCatalogs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCatalogsResponseValidationError{
						field:  fmt.Sprintf("Catalogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCatalogsResponseValidationError{
						field:  fmt.Sprintf("Catalogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCatalogsResponseValidationError{
					field:  fmt.Sprintf("Catalogs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCatalogsResponseMultiError(errors)
	}

	return nil
}

// ListCatalogsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCatalogsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogsResponseMultiError) AllErrors() []error { return m }

// ListCatalogsResponseValidationError is the validation error returned by
// ListCatalogsResponse.Validate if the designated constraints aren't met.
type ListCatalogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogsResponseValidationError) ErrorName() string {
	return "ListCatalogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogsResponseValidationError{}

// Validate checks the field values on UpdateCatalogRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCatalogRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCatalogRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCatalogRequestMultiError, or nil if none found.
func (m *UpdateCatalogRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCatalogRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CatalogId

	// no validation rules for Description

	// no validation rules for NamespaceId

	if len(errors) > 0 {
		return UpdateCatalogRequestMultiError(errors)
	}

	return nil
}

// UpdateCatalogRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCatalogRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateCatalogRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCatalogRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCatalogRequestMultiError) AllErrors() []error { return m }

// UpdateCatalogRequestValidationError is the validation error returned by
// UpdateCatalogRequest.Validate if the designated constraints aren't met.
type UpdateCatalogRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCatalogRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCatalogRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCatalogRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCatalogRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCatalogRequestValidationError) ErrorName() string {
	return "UpdateCatalogRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCatalogRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCatalogRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCatalogRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCatalogRequestValidationError{}

// Validate checks the field values on UpdateCatalogResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCatalogResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCatalogResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCatalogResponseMultiError, or nil if none found.
func (m *UpdateCatalogResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCatalogResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCatalog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCatalogResponseValidationError{
					field:  "Catalog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCatalogResponseValidationError{
					field:  "Catalog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatalog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCatalogResponseValidationError{
				field:  "Catalog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCatalogResponseMultiError(errors)
	}

	return nil
}

// UpdateCatalogResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCatalogResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateCatalogResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCatalogResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCatalogResponseMultiError) AllErrors() []error { return m }

// UpdateCatalogResponseValidationError is the validation error returned by
// UpdateCatalogResponse.Validate if the designated constraints aren't met.
type UpdateCatalogResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCatalogResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCatalogResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCatalogResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCatalogResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCatalogResponseValidationError) ErrorName() string {
	return "UpdateCatalogResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCatalogResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCatalogResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCatalogResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCatalogResponseValidationError{}

// Validate checks the field values on DeleteCatalogRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCatalogRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCatalogRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCatalogRequestMultiError, or nil if none found.
func (m *DeleteCatalogRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCatalogRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for CatalogId

	if len(errors) > 0 {
		return DeleteCatalogRequestMultiError(errors)
	}

	return nil
}

// DeleteCatalogRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCatalogRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteCatalogRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCatalogRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCatalogRequestMultiError) AllErrors() []error { return m }

// DeleteCatalogRequestValidationError is the validation error returned by
// DeleteCatalogRequest.Validate if the designated constraints aren't met.
type DeleteCatalogRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCatalogRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCatalogRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCatalogRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCatalogRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCatalogRequestValidationError) ErrorName() string {
	return "DeleteCatalogRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCatalogRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCatalogRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCatalogRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCatalogRequestValidationError{}

// Validate checks the field values on DeleteCatalogResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCatalogResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCatalogResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCatalogResponseMultiError, or nil if none found.
func (m *DeleteCatalogResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCatalogResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCatalog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteCatalogResponseValidationError{
					field:  "Catalog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteCatalogResponseValidationError{
					field:  "Catalog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatalog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteCatalogResponseValidationError{
				field:  "Catalog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteCatalogResponseMultiError(errors)
	}

	return nil
}

// DeleteCatalogResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCatalogResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteCatalogResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCatalogResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCatalogResponseMultiError) AllErrors() []error { return m }

// DeleteCatalogResponseValidationError is the validation error returned by
// DeleteCatalogResponse.Validate if the designated constraints aren't met.
type DeleteCatalogResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCatalogResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCatalogResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCatalogResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCatalogResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCatalogResponseValidationError) ErrorName() string {
	return "DeleteCatalogResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCatalogResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCatalogResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCatalogResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCatalogResponseValidationError{}

// Validate checks the field values on File with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *File) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on File with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FileMultiError, or nil if none found.
func (m *File) ValidateAll() error {
	return m.validate(true)
}

func (m *File) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileUid

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for ProcessStatus

	// no validation rules for ProcessOutcome

	// no validation rules for Retrievable

	// no validation rules for Content

	// no validation rules for OwnerUid

	// no validation rules for CreatorUid

	// no validation rules for CatalogUid

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Size

	// no validation rules for TotalChunks

	// no validation rules for TotalTokens

	if len(errors) > 0 {
		return FileMultiError(errors)
	}

	return nil
}

// FileMultiError is an error wrapping multiple validation errors returned by
// File.ValidateAll() if the designated constraints aren't met.
type FileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileMultiError) AllErrors() []error { return m }

// FileValidationError is the validation error returned by File.Validate if the
// designated constraints aren't met.
type FileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileValidationError) ErrorName() string { return "FileValidationError" }

// Error satisfies the builtin error interface
func (e FileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileValidationError{}

// Validate checks the field values on UploadCatalogFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UploadCatalogFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadCatalogFileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadCatalogFileRequestMultiError, or nil if none found.
func (m *UploadCatalogFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadCatalogFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for CatalogId

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadCatalogFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadCatalogFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadCatalogFileRequestValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UploadCatalogFileRequestMultiError(errors)
	}

	return nil
}

// UploadCatalogFileRequestMultiError is an error wrapping multiple validation
// errors returned by UploadCatalogFileRequest.ValidateAll() if the designated
// constraints aren't met.
type UploadCatalogFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadCatalogFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadCatalogFileRequestMultiError) AllErrors() []error { return m }

// UploadCatalogFileRequestValidationError is the validation error returned by
// UploadCatalogFileRequest.Validate if the designated constraints aren't met.
type UploadCatalogFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadCatalogFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadCatalogFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadCatalogFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadCatalogFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadCatalogFileRequestValidationError) ErrorName() string {
	return "UploadCatalogFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UploadCatalogFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadCatalogFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadCatalogFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadCatalogFileRequestValidationError{}

// Validate checks the field values on UploadCatalogFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UploadCatalogFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadCatalogFileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadCatalogFileResponseMultiError, or nil if none found.
func (m *UploadCatalogFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadCatalogFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadCatalogFileResponseValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadCatalogFileResponseValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadCatalogFileResponseValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UploadCatalogFileResponseMultiError(errors)
	}

	return nil
}

// UploadCatalogFileResponseMultiError is an error wrapping multiple validation
// errors returned by UploadCatalogFileResponse.ValidateAll() if the
// designated constraints aren't met.
type UploadCatalogFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadCatalogFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadCatalogFileResponseMultiError) AllErrors() []error { return m }

// UploadCatalogFileResponseValidationError is the validation error returned by
// UploadCatalogFileResponse.Validate if the designated constraints aren't met.
type UploadCatalogFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadCatalogFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadCatalogFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadCatalogFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadCatalogFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadCatalogFileResponseValidationError) ErrorName() string {
	return "UploadCatalogFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UploadCatalogFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadCatalogFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadCatalogFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadCatalogFileResponseValidationError{}

// Validate checks the field values on DeleteCatalogFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCatalogFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCatalogFileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCatalogFileRequestMultiError, or nil if none found.
func (m *DeleteCatalogFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCatalogFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileUid

	if len(errors) > 0 {
		return DeleteCatalogFileRequestMultiError(errors)
	}

	return nil
}

// DeleteCatalogFileRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCatalogFileRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteCatalogFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCatalogFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCatalogFileRequestMultiError) AllErrors() []error { return m }

// DeleteCatalogFileRequestValidationError is the validation error returned by
// DeleteCatalogFileRequest.Validate if the designated constraints aren't met.
type DeleteCatalogFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCatalogFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCatalogFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCatalogFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCatalogFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCatalogFileRequestValidationError) ErrorName() string {
	return "DeleteCatalogFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCatalogFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCatalogFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCatalogFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCatalogFileRequestValidationError{}

// Validate checks the field values on DeleteCatalogFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCatalogFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCatalogFileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCatalogFileResponseMultiError, or nil if none found.
func (m *DeleteCatalogFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCatalogFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileUid

	if len(errors) > 0 {
		return DeleteCatalogFileResponseMultiError(errors)
	}

	return nil
}

// DeleteCatalogFileResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCatalogFileResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteCatalogFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCatalogFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCatalogFileResponseMultiError) AllErrors() []error { return m }

// DeleteCatalogFileResponseValidationError is the validation error returned by
// DeleteCatalogFileResponse.Validate if the designated constraints aren't met.
type DeleteCatalogFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCatalogFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCatalogFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCatalogFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCatalogFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCatalogFileResponseValidationError) ErrorName() string {
	return "DeleteCatalogFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCatalogFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCatalogFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCatalogFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCatalogFileResponseValidationError{}

// Validate checks the field values on ProcessCatalogFilesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessCatalogFilesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessCatalogFilesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessCatalogFilesRequestMultiError, or nil if none found.
func (m *ProcessCatalogFilesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessCatalogFilesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ProcessCatalogFilesRequestMultiError(errors)
	}

	return nil
}

// ProcessCatalogFilesRequestMultiError is an error wrapping multiple
// validation errors returned by ProcessCatalogFilesRequest.ValidateAll() if
// the designated constraints aren't met.
type ProcessCatalogFilesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessCatalogFilesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessCatalogFilesRequestMultiError) AllErrors() []error { return m }

// ProcessCatalogFilesRequestValidationError is the validation error returned
// by ProcessCatalogFilesRequest.Validate if the designated constraints aren't met.
type ProcessCatalogFilesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessCatalogFilesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessCatalogFilesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessCatalogFilesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessCatalogFilesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessCatalogFilesRequestValidationError) ErrorName() string {
	return "ProcessCatalogFilesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessCatalogFilesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessCatalogFilesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessCatalogFilesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessCatalogFilesRequestValidationError{}

// Validate checks the field values on ProcessCatalogFilesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessCatalogFilesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessCatalogFilesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessCatalogFilesResponseMultiError, or nil if none found.
func (m *ProcessCatalogFilesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessCatalogFilesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProcessCatalogFilesResponseValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProcessCatalogFilesResponseValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProcessCatalogFilesResponseValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProcessCatalogFilesResponseMultiError(errors)
	}

	return nil
}

// ProcessCatalogFilesResponseMultiError is an error wrapping multiple
// validation errors returned by ProcessCatalogFilesResponse.ValidateAll() if
// the designated constraints aren't met.
type ProcessCatalogFilesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessCatalogFilesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessCatalogFilesResponseMultiError) AllErrors() []error { return m }

// ProcessCatalogFilesResponseValidationError is the validation error returned
// by ProcessCatalogFilesResponse.Validate if the designated constraints
// aren't met.
type ProcessCatalogFilesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessCatalogFilesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessCatalogFilesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessCatalogFilesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessCatalogFilesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessCatalogFilesResponseValidationError) ErrorName() string {
	return "ProcessCatalogFilesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessCatalogFilesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessCatalogFilesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessCatalogFilesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessCatalogFilesResponseValidationError{}

// Validate checks the field values on ListCatalogFilesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogFilesFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogFilesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogFilesFilterMultiError, or nil if none found.
func (m *ListCatalogFilesFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogFilesFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListCatalogFilesFilterMultiError(errors)
	}

	return nil
}

// ListCatalogFilesFilterMultiError is an error wrapping multiple validation
// errors returned by ListCatalogFilesFilter.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogFilesFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogFilesFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogFilesFilterMultiError) AllErrors() []error { return m }

// ListCatalogFilesFilterValidationError is the validation error returned by
// ListCatalogFilesFilter.Validate if the designated constraints aren't met.
type ListCatalogFilesFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogFilesFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogFilesFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogFilesFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogFilesFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogFilesFilterValidationError) ErrorName() string {
	return "ListCatalogFilesFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogFilesFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogFilesFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogFilesFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogFilesFilterValidationError{}

// Validate checks the field values on ListCatalogFilesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogFilesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogFilesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogFilesRequestMultiError, or nil if none found.
func (m *ListCatalogFilesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogFilesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for CatalogId

	// no validation rules for PageSize

	// no validation rules for PageToken

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCatalogFilesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCatalogFilesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCatalogFilesRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCatalogFilesRequestMultiError(errors)
	}

	return nil
}

// ListCatalogFilesRequestMultiError is an error wrapping multiple validation
// errors returned by ListCatalogFilesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogFilesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogFilesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogFilesRequestMultiError) AllErrors() []error { return m }

// ListCatalogFilesRequestValidationError is the validation error returned by
// ListCatalogFilesRequest.Validate if the designated constraints aren't met.
type ListCatalogFilesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogFilesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogFilesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogFilesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogFilesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogFilesRequestValidationError) ErrorName() string {
	return "ListCatalogFilesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogFilesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogFilesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogFilesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogFilesRequestValidationError{}

// Validate checks the field values on ListCatalogFilesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogFilesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogFilesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogFilesResponseMultiError, or nil if none found.
func (m *ListCatalogFilesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogFilesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCatalogFilesResponseValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCatalogFilesResponseValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCatalogFilesResponseValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalSize

	// no validation rules for PageSize

	// no validation rules for NextPageToken

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCatalogFilesResponseValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCatalogFilesResponseValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCatalogFilesResponseValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCatalogFilesResponseMultiError(errors)
	}

	return nil
}

// ListCatalogFilesResponseMultiError is an error wrapping multiple validation
// errors returned by ListCatalogFilesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogFilesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogFilesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogFilesResponseMultiError) AllErrors() []error { return m }

// ListCatalogFilesResponseValidationError is the validation error returned by
// ListCatalogFilesResponse.Validate if the designated constraints aren't met.
type ListCatalogFilesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogFilesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogFilesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogFilesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogFilesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogFilesResponseValidationError) ErrorName() string {
	return "ListCatalogFilesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogFilesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogFilesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogFilesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogFilesResponseValidationError{}

// Validate checks the field values on CatalogRun with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CatalogRun) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CatalogRun with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CatalogRunMultiError, or
// nil if none found.
func (m *CatalogRun) ValidateAll() error {
	return m.validate(true)
}

func (m *CatalogRun) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for CatalogUid

	// no validation rules for Action

	// no validation rules for Status

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CatalogRunValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CatalogRunValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CatalogRunValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.TotalDuration != nil {
		// no validation rules for TotalDuration
	}

	if m.RunnerId != nil {
		// no validation rules for RunnerId
	}

	if m.NamespaceId != nil {
		// no validation rules for NamespaceId
	}

	if m.Payload != nil {

		if all {
			switch v := interface{}(m.GetPayload()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogRunValidationError{
						field:  "Payload",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogRunValidationError{
						field:  "Payload",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogRunValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CompleteTime != nil {

		if all {
			switch v := interface{}(m.GetCompleteTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogRunValidationError{
						field:  "CompleteTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogRunValidationError{
						field:  "CompleteTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCompleteTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogRunValidationError{
					field:  "CompleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Error != nil {
		// no validation rules for Error
	}

	if m.CreditAmount != nil {
		// no validation rules for CreditAmount
	}

	if len(errors) > 0 {
		return CatalogRunMultiError(errors)
	}

	return nil
}

// CatalogRunMultiError is an error wrapping multiple validation errors
// returned by CatalogRun.ValidateAll() if the designated constraints aren't met.
type CatalogRunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CatalogRunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CatalogRunMultiError) AllErrors() []error { return m }

// CatalogRunValidationError is the validation error returned by
// CatalogRun.Validate if the designated constraints aren't met.
type CatalogRunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CatalogRunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CatalogRunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CatalogRunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CatalogRunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CatalogRunValidationError) ErrorName() string { return "CatalogRunValidationError" }

// Error satisfies the builtin error interface
func (e CatalogRunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCatalogRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CatalogRunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CatalogRunValidationError{}

// Validate checks the field values on ListCatalogRunsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogRunsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogRunsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogRunsResponseMultiError, or nil if none found.
func (m *ListCatalogRunsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogRunsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCatalogRuns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCatalogRunsResponseValidationError{
						field:  fmt.Sprintf("CatalogRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCatalogRunsResponseValidationError{
						field:  fmt.Sprintf("CatalogRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCatalogRunsResponseValidationError{
					field:  fmt.Sprintf("CatalogRuns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalSize

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListCatalogRunsResponseMultiError(errors)
	}

	return nil
}

// ListCatalogRunsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCatalogRunsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogRunsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogRunsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogRunsResponseMultiError) AllErrors() []error { return m }

// ListCatalogRunsResponseValidationError is the validation error returned by
// ListCatalogRunsResponse.Validate if the designated constraints aren't met.
type ListCatalogRunsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogRunsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogRunsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogRunsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogRunsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogRunsResponseValidationError) ErrorName() string {
	return "ListCatalogRunsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogRunsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogRunsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogRunsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogRunsResponseValidationError{}

// Validate checks the field values on ListCatalogRunsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogRunsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogRunsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogRunsRequestMultiError, or nil if none found.
func (m *ListCatalogRunsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogRunsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for CatalogId

	// no validation rules for Page

	// no validation rules for PageSize

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.OrderBy != nil {
		// no validation rules for OrderBy
	}

	if len(errors) > 0 {
		return ListCatalogRunsRequestMultiError(errors)
	}

	return nil
}

// ListCatalogRunsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCatalogRunsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCatalogRunsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogRunsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogRunsRequestMultiError) AllErrors() []error { return m }

// ListCatalogRunsRequestValidationError is the validation error returned by
// ListCatalogRunsRequest.Validate if the designated constraints aren't met.
type ListCatalogRunsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogRunsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogRunsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogRunsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogRunsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogRunsRequestValidationError) ErrorName() string {
	return "ListCatalogRunsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogRunsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogRunsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogRunsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogRunsRequestValidationError{}
