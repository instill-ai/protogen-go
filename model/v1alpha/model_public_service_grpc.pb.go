// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: model/v1alpha/model_public_service.proto

package modelv1alpha

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ModelPublicService_Liveness_FullMethodName                            = "/model.v1alpha.ModelPublicService/Liveness"
	ModelPublicService_Readiness_FullMethodName                           = "/model.v1alpha.ModelPublicService/Readiness"
	ModelPublicService_ListModelDefinitions_FullMethodName                = "/model.v1alpha.ModelPublicService/ListModelDefinitions"
	ModelPublicService_ListAvailableRegions_FullMethodName                = "/model.v1alpha.ModelPublicService/ListAvailableRegions"
	ModelPublicService_GetModelDefinition_FullMethodName                  = "/model.v1alpha.ModelPublicService/GetModelDefinition"
	ModelPublicService_ListPublicModels_FullMethodName                    = "/model.v1alpha.ModelPublicService/ListPublicModels"
	ModelPublicService_ListModels_FullMethodName                          = "/model.v1alpha.ModelPublicService/ListModels"
	ModelPublicService_CreateModel_FullMethodName                         = "/model.v1alpha.ModelPublicService/CreateModel"
	ModelPublicService_GetModel_FullMethodName                            = "/model.v1alpha.ModelPublicService/GetModel"
	ModelPublicService_UpdateModel_FullMethodName                         = "/model.v1alpha.ModelPublicService/UpdateModel"
	ModelPublicService_DeleteModel_FullMethodName                         = "/model.v1alpha.ModelPublicService/DeleteModel"
	ModelPublicService_RenameModel_FullMethodName                         = "/model.v1alpha.ModelPublicService/RenameModel"
	ModelPublicService_WatchModelVersion_FullMethodName                   = "/model.v1alpha.ModelPublicService/WatchModelVersion"
	ModelPublicService_WatchModel_FullMethodName                          = "/model.v1alpha.ModelPublicService/WatchModel"
	ModelPublicService_ListModelVersions_FullMethodName                   = "/model.v1alpha.ModelPublicService/ListModelVersions"
	ModelPublicService_DeleteModelVersion_FullMethodName                  = "/model.v1alpha.ModelPublicService/DeleteModelVersion"
	ModelPublicService_TriggerModelVersion_FullMethodName                 = "/model.v1alpha.ModelPublicService/TriggerModelVersion"
	ModelPublicService_TriggerAsyncModelVersion_FullMethodName            = "/model.v1alpha.ModelPublicService/TriggerAsyncModelVersion"
	ModelPublicService_TriggerModel_FullMethodName                        = "/model.v1alpha.ModelPublicService/TriggerModel"
	ModelPublicService_TriggerAsyncModel_FullMethodName                   = "/model.v1alpha.ModelPublicService/TriggerAsyncModel"
	ModelPublicService_TriggerModelVersionBinaryFileUpload_FullMethodName = "/model.v1alpha.ModelPublicService/TriggerModelVersionBinaryFileUpload"
	ModelPublicService_TriggerModelBinaryFileUpload_FullMethodName        = "/model.v1alpha.ModelPublicService/TriggerModelBinaryFileUpload"
	ModelPublicService_GetModelVersionOperation_FullMethodName            = "/model.v1alpha.ModelPublicService/GetModelVersionOperation"
	ModelPublicService_GetModelOperation_FullMethodName                   = "/model.v1alpha.ModelPublicService/GetModelOperation"
	ModelPublicService_GetOperation_FullMethodName                        = "/model.v1alpha.ModelPublicService/GetOperation"
	ModelPublicService_ListModelRuns_FullMethodName                       = "/model.v1alpha.ModelPublicService/ListModelRuns"
	ModelPublicService_ListModelRunsByRequester_FullMethodName            = "/model.v1alpha.ModelPublicService/ListModelRunsByRequester"
)

// ModelPublicServiceClient is the client API for ModelPublicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// # Model
//
// ModelPublicService exposes the public endpoints that allow clients to manage
// models.
type ModelPublicServiceClient interface {
	// Check if the model server is alive
	//
	// See https://github.com/grpc/grpc/blob/master/doc/health-checking.md.
	Liveness(ctx context.Context, in *LivenessRequest, opts ...grpc.CallOption) (*LivenessResponse, error)
	// Check if the model server is ready
	//
	// See https://github.com/grpc/grpc/blob/master/doc/health-checking.md
	Readiness(ctx context.Context, in *ReadinessRequest, opts ...grpc.CallOption) (*ReadinessResponse, error)
	// List model definitions
	//
	// Returns a paginated list of model definitions.
	ListModelDefinitions(ctx context.Context, in *ListModelDefinitionsRequest, opts ...grpc.CallOption) (*ListModelDefinitionsResponse, error)
	// List available regions
	//
	// Returns a paginated list of available regions.
	ListAvailableRegions(ctx context.Context, in *ListAvailableRegionsRequest, opts ...grpc.CallOption) (*ListAvailableRegionsResponse, error)
	// Get a model definition
	//
	// Returns the details of a model definition.
	GetModelDefinition(ctx context.Context, in *GetModelDefinitionRequest, opts ...grpc.CallOption) (*GetModelDefinitionResponse, error)
	// List public models
	//
	// Returns a paginated list of public models.
	ListPublicModels(ctx context.Context, in *ListPublicModelsRequest, opts ...grpc.CallOption) (*ListPublicModelsResponse, error)
	// List models
	//
	// Returns a paginated list of models.
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error)
	// Create a new model
	//
	// Creates a new model under the parenthood of a namespace. This is an
	// asynchronous endpoint, i.e., the server will not wait for the model to be
	// created in order to respond. Instead, it will return a response with the
	// necessary information to access the result and status of the creation
	// operation.
	CreateModel(ctx context.Context, in *CreateModelRequest, opts ...grpc.CallOption) (*CreateModelResponse, error)
	// Get a model
	//
	// Returns the detail of a model, accessing it by the model ID and its parent
	// namespace.
	GetModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*GetModelResponse, error)
	// Update a model
	//
	// Updates a model, accessing it by its resource name, which is defined by
	// the parent namespace and the ID of the model.
	//
	// In REST requests, only the supplied model fields will be taken into
	// account when updating the resource.
	UpdateModel(ctx context.Context, in *UpdateModelRequest, opts ...grpc.CallOption) (*UpdateModelResponse, error)
	// Delete a model
	//
	// Deletes a model, accesing it by its resource name, which is defined by the
	// parent namespace and the ID of the model.
	DeleteModel(ctx context.Context, in *DeleteModelRequest, opts ...grpc.CallOption) (*DeleteModelResponse, error)
	// Rename a model
	//
	// Renames a model, accesing it by its resource name, which is defined by the
	// parent namespace and the ID of the model.
	RenameModel(ctx context.Context, in *RenameModelRequest, opts ...grpc.CallOption) (*RenameModelResponse, error)
	// Watch the state of a model version
	//
	// Returns the state of a model. The model resource allocation and scaling
	// actions take some time, during which a model will be in various state. This
	// endpoint allows clients to track the state.
	WatchModelVersion(ctx context.Context, in *WatchModelVersionRequest, opts ...grpc.CallOption) (*WatchModelVersionResponse, error)
	// Watch the state of the latest model version
	//
	// Returns the state of the latest model version. The model resource
	// allocation and scaling actions take some time, during which a model will be
	// in various state. This endpoint allows clients to track the state.
	WatchModel(ctx context.Context, in *WatchModelRequest, opts ...grpc.CallOption) (*WatchModelResponse, error)
	// List namespace model versions
	//
	// Returns a paginated list of version of a model namespace that belong to the
	// specified namespace. Contains model version and digest.
	ListModelVersions(ctx context.Context, in *ListModelVersionsRequest, opts ...grpc.CallOption) (*ListModelVersionsResponse, error)
	// Delete a model version
	//
	// Deletes a model version, accesing it by its resource name, which is defined
	// by the parent namespace and the ID of the model, and version.
	DeleteModelVersion(ctx context.Context, in *DeleteModelVersionRequest, opts ...grpc.CallOption) (*DeleteModelVersionResponse, error)
	// Trigger model inference
	//
	// Triggers a deployed model to infer the result of a set of task or
	// questions.
	TriggerModelVersion(ctx context.Context, in *TriggerModelVersionRequest, opts ...grpc.CallOption) (*TriggerModelVersionResponse, error)
	// Trigger model inference asynchronously
	//
	// Triggers a deployed model to infer the result of a set of task or
	// questions.
	TriggerAsyncModelVersion(ctx context.Context, in *TriggerAsyncModelVersionRequest, opts ...grpc.CallOption) (*TriggerAsyncModelVersionResponse, error)
	// Trigger model inference
	//
	// Triggers the latest deployed model version to infer the result of a set of
	// task or questions.
	TriggerModel(ctx context.Context, in *TriggerModelRequest, opts ...grpc.CallOption) (*TriggerModelResponse, error)
	// Trigger model inference asynchronously
	//
	// Triggers the latest deployed model version to infer the result of a set of
	// task or questions.
	TriggerAsyncModel(ctx context.Context, in *TriggerAsyncModelRequest, opts ...grpc.CallOption) (*TriggerAsyncModelResponse, error)
	// Trigger model inference with a binary input
	//
	// Triggers a deployed model to infer the result of a task or question,
	// submitted as a binary file.
	TriggerModelVersionBinaryFileUpload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse], error)
	// Trigger model inference with a binary input
	//
	// Triggers the latest deployed model version to infer the result of a set of
	// task or questions, submitted as a binary file.
	TriggerModelBinaryFileUpload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse], error)
	// Get the details of the long-running operation from a model version
	//
	// This method allows requesters to request the status and outcome of
	// long-running operations in a model, such as trigger.
	GetModelVersionOperation(ctx context.Context, in *GetModelVersionOperationRequest, opts ...grpc.CallOption) (*GetModelVersionOperationResponse, error)
	// Get the details of the latest long-running operation from a model
	//
	// This method allows requesters to request the status and outcome of
	// long-running operations in a model, such as trigger.
	GetModelOperation(ctx context.Context, in *GetModelOperationRequest, opts ...grpc.CallOption) (*GetModelOperationResponse, error)
	// Get the details of a long-running operation
	//
	// This method allows requesters to request the status and outcome of
	// long-running operations in a model, such as trigger.
	GetOperation(ctx context.Context, in *GetOperationRequest, opts ...grpc.CallOption) (*GetOperationResponse, error)
	// List Model Runs
	//
	// Returns a paginated list of runs for a given model. When the requester is
	// the owner of the model, they will be able to all the model runs,
	// regardless who requested the trigger (the view will be partial to hide
	// sensitive data like e.g. the trigger input and output). Other requesters
	// will only be able to see the runs requested by themselves.
	ListModelRuns(ctx context.Context, in *ListModelRunsRequest, opts ...grpc.CallOption) (*ListModelRunsResponse, error)
	// List Model Runs By Requester
	//
	// Returns a paginated list of runs requested by a namespace. The response
	// may contain runs from several models.
	ListModelRunsByRequester(ctx context.Context, in *ListModelRunsByRequesterRequest, opts ...grpc.CallOption) (*ListModelRunsByRequesterResponse, error)
}

type modelPublicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewModelPublicServiceClient(cc grpc.ClientConnInterface) ModelPublicServiceClient {
	return &modelPublicServiceClient{cc}
}

func (c *modelPublicServiceClient) Liveness(ctx context.Context, in *LivenessRequest, opts ...grpc.CallOption) (*LivenessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LivenessResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_Liveness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) Readiness(ctx context.Context, in *ReadinessRequest, opts ...grpc.CallOption) (*ReadinessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadinessResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_Readiness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListModelDefinitions(ctx context.Context, in *ListModelDefinitionsRequest, opts ...grpc.CallOption) (*ListModelDefinitionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelDefinitionsResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListModelDefinitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListAvailableRegions(ctx context.Context, in *ListAvailableRegionsRequest, opts ...grpc.CallOption) (*ListAvailableRegionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAvailableRegionsResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListAvailableRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) GetModelDefinition(ctx context.Context, in *GetModelDefinitionRequest, opts ...grpc.CallOption) (*GetModelDefinitionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelDefinitionResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_GetModelDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListPublicModels(ctx context.Context, in *ListPublicModelsRequest, opts ...grpc.CallOption) (*ListPublicModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPublicModelsResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListPublicModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) CreateModel(ctx context.Context, in *CreateModelRequest, opts ...grpc.CallOption) (*CreateModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_CreateModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) GetModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*GetModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_GetModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) UpdateModel(ctx context.Context, in *UpdateModelRequest, opts ...grpc.CallOption) (*UpdateModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_UpdateModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) DeleteModel(ctx context.Context, in *DeleteModelRequest, opts ...grpc.CallOption) (*DeleteModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_DeleteModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) RenameModel(ctx context.Context, in *RenameModelRequest, opts ...grpc.CallOption) (*RenameModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenameModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_RenameModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) WatchModelVersion(ctx context.Context, in *WatchModelVersionRequest, opts ...grpc.CallOption) (*WatchModelVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WatchModelVersionResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_WatchModelVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) WatchModel(ctx context.Context, in *WatchModelRequest, opts ...grpc.CallOption) (*WatchModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WatchModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_WatchModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListModelVersions(ctx context.Context, in *ListModelVersionsRequest, opts ...grpc.CallOption) (*ListModelVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelVersionsResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListModelVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) DeleteModelVersion(ctx context.Context, in *DeleteModelVersionRequest, opts ...grpc.CallOption) (*DeleteModelVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteModelVersionResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_DeleteModelVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) TriggerModelVersion(ctx context.Context, in *TriggerModelVersionRequest, opts ...grpc.CallOption) (*TriggerModelVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerModelVersionResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_TriggerModelVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) TriggerAsyncModelVersion(ctx context.Context, in *TriggerAsyncModelVersionRequest, opts ...grpc.CallOption) (*TriggerAsyncModelVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerAsyncModelVersionResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_TriggerAsyncModelVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) TriggerModel(ctx context.Context, in *TriggerModelRequest, opts ...grpc.CallOption) (*TriggerModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_TriggerModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) TriggerAsyncModel(ctx context.Context, in *TriggerAsyncModelRequest, opts ...grpc.CallOption) (*TriggerAsyncModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerAsyncModelResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_TriggerAsyncModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) TriggerModelVersionBinaryFileUpload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ModelPublicService_ServiceDesc.Streams[0], ModelPublicService_TriggerModelVersionBinaryFileUpload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ModelPublicService_TriggerModelVersionBinaryFileUploadClient = grpc.ClientStreamingClient[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse]

func (c *modelPublicServiceClient) TriggerModelBinaryFileUpload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ModelPublicService_ServiceDesc.Streams[1], ModelPublicService_TriggerModelBinaryFileUpload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ModelPublicService_TriggerModelBinaryFileUploadClient = grpc.ClientStreamingClient[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse]

func (c *modelPublicServiceClient) GetModelVersionOperation(ctx context.Context, in *GetModelVersionOperationRequest, opts ...grpc.CallOption) (*GetModelVersionOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelVersionOperationResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_GetModelVersionOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) GetModelOperation(ctx context.Context, in *GetModelOperationRequest, opts ...grpc.CallOption) (*GetModelOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelOperationResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_GetModelOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) GetOperation(ctx context.Context, in *GetOperationRequest, opts ...grpc.CallOption) (*GetOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOperationResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_GetOperation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListModelRuns(ctx context.Context, in *ListModelRunsRequest, opts ...grpc.CallOption) (*ListModelRunsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelRunsResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListModelRuns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPublicServiceClient) ListModelRunsByRequester(ctx context.Context, in *ListModelRunsByRequesterRequest, opts ...grpc.CallOption) (*ListModelRunsByRequesterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelRunsByRequesterResponse)
	err := c.cc.Invoke(ctx, ModelPublicService_ListModelRunsByRequester_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModelPublicServiceServer is the server API for ModelPublicService service.
// All implementations should embed UnimplementedModelPublicServiceServer
// for forward compatibility.
//
// # Model
//
// ModelPublicService exposes the public endpoints that allow clients to manage
// models.
type ModelPublicServiceServer interface {
	// Check if the model server is alive
	//
	// See https://github.com/grpc/grpc/blob/master/doc/health-checking.md.
	Liveness(context.Context, *LivenessRequest) (*LivenessResponse, error)
	// Check if the model server is ready
	//
	// See https://github.com/grpc/grpc/blob/master/doc/health-checking.md
	Readiness(context.Context, *ReadinessRequest) (*ReadinessResponse, error)
	// List model definitions
	//
	// Returns a paginated list of model definitions.
	ListModelDefinitions(context.Context, *ListModelDefinitionsRequest) (*ListModelDefinitionsResponse, error)
	// List available regions
	//
	// Returns a paginated list of available regions.
	ListAvailableRegions(context.Context, *ListAvailableRegionsRequest) (*ListAvailableRegionsResponse, error)
	// Get a model definition
	//
	// Returns the details of a model definition.
	GetModelDefinition(context.Context, *GetModelDefinitionRequest) (*GetModelDefinitionResponse, error)
	// List public models
	//
	// Returns a paginated list of public models.
	ListPublicModels(context.Context, *ListPublicModelsRequest) (*ListPublicModelsResponse, error)
	// List models
	//
	// Returns a paginated list of models.
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
	// Create a new model
	//
	// Creates a new model under the parenthood of a namespace. This is an
	// asynchronous endpoint, i.e., the server will not wait for the model to be
	// created in order to respond. Instead, it will return a response with the
	// necessary information to access the result and status of the creation
	// operation.
	CreateModel(context.Context, *CreateModelRequest) (*CreateModelResponse, error)
	// Get a model
	//
	// Returns the detail of a model, accessing it by the model ID and its parent
	// namespace.
	GetModel(context.Context, *GetModelRequest) (*GetModelResponse, error)
	// Update a model
	//
	// Updates a model, accessing it by its resource name, which is defined by
	// the parent namespace and the ID of the model.
	//
	// In REST requests, only the supplied model fields will be taken into
	// account when updating the resource.
	UpdateModel(context.Context, *UpdateModelRequest) (*UpdateModelResponse, error)
	// Delete a model
	//
	// Deletes a model, accesing it by its resource name, which is defined by the
	// parent namespace and the ID of the model.
	DeleteModel(context.Context, *DeleteModelRequest) (*DeleteModelResponse, error)
	// Rename a model
	//
	// Renames a model, accesing it by its resource name, which is defined by the
	// parent namespace and the ID of the model.
	RenameModel(context.Context, *RenameModelRequest) (*RenameModelResponse, error)
	// Watch the state of a model version
	//
	// Returns the state of a model. The model resource allocation and scaling
	// actions take some time, during which a model will be in various state. This
	// endpoint allows clients to track the state.
	WatchModelVersion(context.Context, *WatchModelVersionRequest) (*WatchModelVersionResponse, error)
	// Watch the state of the latest model version
	//
	// Returns the state of the latest model version. The model resource
	// allocation and scaling actions take some time, during which a model will be
	// in various state. This endpoint allows clients to track the state.
	WatchModel(context.Context, *WatchModelRequest) (*WatchModelResponse, error)
	// List namespace model versions
	//
	// Returns a paginated list of version of a model namespace that belong to the
	// specified namespace. Contains model version and digest.
	ListModelVersions(context.Context, *ListModelVersionsRequest) (*ListModelVersionsResponse, error)
	// Delete a model version
	//
	// Deletes a model version, accesing it by its resource name, which is defined
	// by the parent namespace and the ID of the model, and version.
	DeleteModelVersion(context.Context, *DeleteModelVersionRequest) (*DeleteModelVersionResponse, error)
	// Trigger model inference
	//
	// Triggers a deployed model to infer the result of a set of task or
	// questions.
	TriggerModelVersion(context.Context, *TriggerModelVersionRequest) (*TriggerModelVersionResponse, error)
	// Trigger model inference asynchronously
	//
	// Triggers a deployed model to infer the result of a set of task or
	// questions.
	TriggerAsyncModelVersion(context.Context, *TriggerAsyncModelVersionRequest) (*TriggerAsyncModelVersionResponse, error)
	// Trigger model inference
	//
	// Triggers the latest deployed model version to infer the result of a set of
	// task or questions.
	TriggerModel(context.Context, *TriggerModelRequest) (*TriggerModelResponse, error)
	// Trigger model inference asynchronously
	//
	// Triggers the latest deployed model version to infer the result of a set of
	// task or questions.
	TriggerAsyncModel(context.Context, *TriggerAsyncModelRequest) (*TriggerAsyncModelResponse, error)
	// Trigger model inference with a binary input
	//
	// Triggers a deployed model to infer the result of a task or question,
	// submitted as a binary file.
	TriggerModelVersionBinaryFileUpload(grpc.ClientStreamingServer[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse]) error
	// Trigger model inference with a binary input
	//
	// Triggers the latest deployed model version to infer the result of a set of
	// task or questions, submitted as a binary file.
	TriggerModelBinaryFileUpload(grpc.ClientStreamingServer[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse]) error
	// Get the details of the long-running operation from a model version
	//
	// This method allows requesters to request the status and outcome of
	// long-running operations in a model, such as trigger.
	GetModelVersionOperation(context.Context, *GetModelVersionOperationRequest) (*GetModelVersionOperationResponse, error)
	// Get the details of the latest long-running operation from a model
	//
	// This method allows requesters to request the status and outcome of
	// long-running operations in a model, such as trigger.
	GetModelOperation(context.Context, *GetModelOperationRequest) (*GetModelOperationResponse, error)
	// Get the details of a long-running operation
	//
	// This method allows requesters to request the status and outcome of
	// long-running operations in a model, such as trigger.
	GetOperation(context.Context, *GetOperationRequest) (*GetOperationResponse, error)
	// List Model Runs
	//
	// Returns a paginated list of runs for a given model. When the requester is
	// the owner of the model, they will be able to all the model runs,
	// regardless who requested the trigger (the view will be partial to hide
	// sensitive data like e.g. the trigger input and output). Other requesters
	// will only be able to see the runs requested by themselves.
	ListModelRuns(context.Context, *ListModelRunsRequest) (*ListModelRunsResponse, error)
	// List Model Runs By Requester
	//
	// Returns a paginated list of runs requested by a namespace. The response
	// may contain runs from several models.
	ListModelRunsByRequester(context.Context, *ListModelRunsByRequesterRequest) (*ListModelRunsByRequesterResponse, error)
}

// UnimplementedModelPublicServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedModelPublicServiceServer struct{}

func (UnimplementedModelPublicServiceServer) Liveness(context.Context, *LivenessRequest) (*LivenessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Liveness not implemented")
}
func (UnimplementedModelPublicServiceServer) Readiness(context.Context, *ReadinessRequest) (*ReadinessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Readiness not implemented")
}
func (UnimplementedModelPublicServiceServer) ListModelDefinitions(context.Context, *ListModelDefinitionsRequest) (*ListModelDefinitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelDefinitions not implemented")
}
func (UnimplementedModelPublicServiceServer) ListAvailableRegions(context.Context, *ListAvailableRegionsRequest) (*ListAvailableRegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableRegions not implemented")
}
func (UnimplementedModelPublicServiceServer) GetModelDefinition(context.Context, *GetModelDefinitionRequest) (*GetModelDefinitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelDefinition not implemented")
}
func (UnimplementedModelPublicServiceServer) ListPublicModels(context.Context, *ListPublicModelsRequest) (*ListPublicModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPublicModels not implemented")
}
func (UnimplementedModelPublicServiceServer) ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}
func (UnimplementedModelPublicServiceServer) CreateModel(context.Context, *CreateModelRequest) (*CreateModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateModel not implemented")
}
func (UnimplementedModelPublicServiceServer) GetModel(context.Context, *GetModelRequest) (*GetModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModel not implemented")
}
func (UnimplementedModelPublicServiceServer) UpdateModel(context.Context, *UpdateModelRequest) (*UpdateModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateModel not implemented")
}
func (UnimplementedModelPublicServiceServer) DeleteModel(context.Context, *DeleteModelRequest) (*DeleteModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteModel not implemented")
}
func (UnimplementedModelPublicServiceServer) RenameModel(context.Context, *RenameModelRequest) (*RenameModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameModel not implemented")
}
func (UnimplementedModelPublicServiceServer) WatchModelVersion(context.Context, *WatchModelVersionRequest) (*WatchModelVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WatchModelVersion not implemented")
}
func (UnimplementedModelPublicServiceServer) WatchModel(context.Context, *WatchModelRequest) (*WatchModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WatchModel not implemented")
}
func (UnimplementedModelPublicServiceServer) ListModelVersions(context.Context, *ListModelVersionsRequest) (*ListModelVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelVersions not implemented")
}
func (UnimplementedModelPublicServiceServer) DeleteModelVersion(context.Context, *DeleteModelVersionRequest) (*DeleteModelVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteModelVersion not implemented")
}
func (UnimplementedModelPublicServiceServer) TriggerModelVersion(context.Context, *TriggerModelVersionRequest) (*TriggerModelVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerModelVersion not implemented")
}
func (UnimplementedModelPublicServiceServer) TriggerAsyncModelVersion(context.Context, *TriggerAsyncModelVersionRequest) (*TriggerAsyncModelVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerAsyncModelVersion not implemented")
}
func (UnimplementedModelPublicServiceServer) TriggerModel(context.Context, *TriggerModelRequest) (*TriggerModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerModel not implemented")
}
func (UnimplementedModelPublicServiceServer) TriggerAsyncModel(context.Context, *TriggerAsyncModelRequest) (*TriggerAsyncModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerAsyncModel not implemented")
}
func (UnimplementedModelPublicServiceServer) TriggerModelVersionBinaryFileUpload(grpc.ClientStreamingServer[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse]) error {
	return status.Errorf(codes.Unimplemented, "method TriggerModelVersionBinaryFileUpload not implemented")
}
func (UnimplementedModelPublicServiceServer) TriggerModelBinaryFileUpload(grpc.ClientStreamingServer[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse]) error {
	return status.Errorf(codes.Unimplemented, "method TriggerModelBinaryFileUpload not implemented")
}
func (UnimplementedModelPublicServiceServer) GetModelVersionOperation(context.Context, *GetModelVersionOperationRequest) (*GetModelVersionOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelVersionOperation not implemented")
}
func (UnimplementedModelPublicServiceServer) GetModelOperation(context.Context, *GetModelOperationRequest) (*GetModelOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelOperation not implemented")
}
func (UnimplementedModelPublicServiceServer) GetOperation(context.Context, *GetOperationRequest) (*GetOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOperation not implemented")
}
func (UnimplementedModelPublicServiceServer) ListModelRuns(context.Context, *ListModelRunsRequest) (*ListModelRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelRuns not implemented")
}
func (UnimplementedModelPublicServiceServer) ListModelRunsByRequester(context.Context, *ListModelRunsByRequesterRequest) (*ListModelRunsByRequesterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelRunsByRequester not implemented")
}
func (UnimplementedModelPublicServiceServer) testEmbeddedByValue() {}

// UnsafeModelPublicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModelPublicServiceServer will
// result in compilation errors.
type UnsafeModelPublicServiceServer interface {
	mustEmbedUnimplementedModelPublicServiceServer()
}

func RegisterModelPublicServiceServer(s grpc.ServiceRegistrar, srv ModelPublicServiceServer) {
	// If the following call pancis, it indicates UnimplementedModelPublicServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ModelPublicService_ServiceDesc, srv)
}

func _ModelPublicService_Liveness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LivenessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).Liveness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_Liveness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).Liveness(ctx, req.(*LivenessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_Readiness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadinessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).Readiness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_Readiness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).Readiness(ctx, req.(*ReadinessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListModelDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelDefinitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListModelDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListModelDefinitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListModelDefinitions(ctx, req.(*ListModelDefinitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListAvailableRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListAvailableRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListAvailableRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListAvailableRegions(ctx, req.(*ListAvailableRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_GetModelDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelDefinitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).GetModelDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_GetModelDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).GetModelDefinition(ctx, req.(*GetModelDefinitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListPublicModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPublicModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListPublicModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListPublicModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListPublicModels(ctx, req.(*ListPublicModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_CreateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).CreateModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_CreateModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).CreateModel(ctx, req.(*CreateModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_GetModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).GetModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_GetModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).GetModel(ctx, req.(*GetModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_UpdateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).UpdateModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_UpdateModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).UpdateModel(ctx, req.(*UpdateModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_DeleteModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).DeleteModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_DeleteModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).DeleteModel(ctx, req.(*DeleteModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_RenameModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).RenameModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_RenameModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).RenameModel(ctx, req.(*RenameModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_WatchModelVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WatchModelVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).WatchModelVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_WatchModelVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).WatchModelVersion(ctx, req.(*WatchModelVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_WatchModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WatchModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).WatchModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_WatchModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).WatchModel(ctx, req.(*WatchModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListModelVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListModelVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListModelVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListModelVersions(ctx, req.(*ListModelVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_DeleteModelVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteModelVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).DeleteModelVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_DeleteModelVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).DeleteModelVersion(ctx, req.(*DeleteModelVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_TriggerModelVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerModelVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).TriggerModelVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_TriggerModelVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).TriggerModelVersion(ctx, req.(*TriggerModelVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_TriggerAsyncModelVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerAsyncModelVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).TriggerAsyncModelVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_TriggerAsyncModelVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).TriggerAsyncModelVersion(ctx, req.(*TriggerAsyncModelVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_TriggerModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).TriggerModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_TriggerModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).TriggerModel(ctx, req.(*TriggerModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_TriggerAsyncModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerAsyncModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).TriggerAsyncModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_TriggerAsyncModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).TriggerAsyncModel(ctx, req.(*TriggerAsyncModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_TriggerModelVersionBinaryFileUpload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ModelPublicServiceServer).TriggerModelVersionBinaryFileUpload(&grpc.GenericServerStream[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ModelPublicService_TriggerModelVersionBinaryFileUploadServer = grpc.ClientStreamingServer[TriggerModelVersionBinaryFileUploadRequest, TriggerModelVersionBinaryFileUploadResponse]

func _ModelPublicService_TriggerModelBinaryFileUpload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ModelPublicServiceServer).TriggerModelBinaryFileUpload(&grpc.GenericServerStream[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ModelPublicService_TriggerModelBinaryFileUploadServer = grpc.ClientStreamingServer[TriggerModelBinaryFileUploadRequest, TriggerModelBinaryFileUploadResponse]

func _ModelPublicService_GetModelVersionOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelVersionOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).GetModelVersionOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_GetModelVersionOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).GetModelVersionOperation(ctx, req.(*GetModelVersionOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_GetModelOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).GetModelOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_GetModelOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).GetModelOperation(ctx, req.(*GetModelOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_GetOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).GetOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_GetOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).GetOperation(ctx, req.(*GetOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListModelRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListModelRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListModelRuns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListModelRuns(ctx, req.(*ListModelRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPublicService_ListModelRunsByRequester_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelRunsByRequesterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPublicServiceServer).ListModelRunsByRequester(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModelPublicService_ListModelRunsByRequester_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPublicServiceServer).ListModelRunsByRequester(ctx, req.(*ListModelRunsByRequesterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ModelPublicService_ServiceDesc is the grpc.ServiceDesc for ModelPublicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModelPublicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "model.v1alpha.ModelPublicService",
	HandlerType: (*ModelPublicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Liveness",
			Handler:    _ModelPublicService_Liveness_Handler,
		},
		{
			MethodName: "Readiness",
			Handler:    _ModelPublicService_Readiness_Handler,
		},
		{
			MethodName: "ListModelDefinitions",
			Handler:    _ModelPublicService_ListModelDefinitions_Handler,
		},
		{
			MethodName: "ListAvailableRegions",
			Handler:    _ModelPublicService_ListAvailableRegions_Handler,
		},
		{
			MethodName: "GetModelDefinition",
			Handler:    _ModelPublicService_GetModelDefinition_Handler,
		},
		{
			MethodName: "ListPublicModels",
			Handler:    _ModelPublicService_ListPublicModels_Handler,
		},
		{
			MethodName: "ListModels",
			Handler:    _ModelPublicService_ListModels_Handler,
		},
		{
			MethodName: "CreateModel",
			Handler:    _ModelPublicService_CreateModel_Handler,
		},
		{
			MethodName: "GetModel",
			Handler:    _ModelPublicService_GetModel_Handler,
		},
		{
			MethodName: "UpdateModel",
			Handler:    _ModelPublicService_UpdateModel_Handler,
		},
		{
			MethodName: "DeleteModel",
			Handler:    _ModelPublicService_DeleteModel_Handler,
		},
		{
			MethodName: "RenameModel",
			Handler:    _ModelPublicService_RenameModel_Handler,
		},
		{
			MethodName: "WatchModelVersion",
			Handler:    _ModelPublicService_WatchModelVersion_Handler,
		},
		{
			MethodName: "WatchModel",
			Handler:    _ModelPublicService_WatchModel_Handler,
		},
		{
			MethodName: "ListModelVersions",
			Handler:    _ModelPublicService_ListModelVersions_Handler,
		},
		{
			MethodName: "DeleteModelVersion",
			Handler:    _ModelPublicService_DeleteModelVersion_Handler,
		},
		{
			MethodName: "TriggerModelVersion",
			Handler:    _ModelPublicService_TriggerModelVersion_Handler,
		},
		{
			MethodName: "TriggerAsyncModelVersion",
			Handler:    _ModelPublicService_TriggerAsyncModelVersion_Handler,
		},
		{
			MethodName: "TriggerModel",
			Handler:    _ModelPublicService_TriggerModel_Handler,
		},
		{
			MethodName: "TriggerAsyncModel",
			Handler:    _ModelPublicService_TriggerAsyncModel_Handler,
		},
		{
			MethodName: "GetModelVersionOperation",
			Handler:    _ModelPublicService_GetModelVersionOperation_Handler,
		},
		{
			MethodName: "GetModelOperation",
			Handler:    _ModelPublicService_GetModelOperation_Handler,
		},
		{
			MethodName: "GetOperation",
			Handler:    _ModelPublicService_GetOperation_Handler,
		},
		{
			MethodName: "ListModelRuns",
			Handler:    _ModelPublicService_ListModelRuns_Handler,
		},
		{
			MethodName: "ListModelRunsByRequester",
			Handler:    _ModelPublicService_ListModelRunsByRequester_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TriggerModelVersionBinaryFileUpload",
			Handler:       _ModelPublicService_TriggerModelVersionBinaryFileUpload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "TriggerModelBinaryFileUpload",
			Handler:       _ModelPublicService_TriggerModelBinaryFileUpload_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "model/v1alpha/model_public_service.proto",
}
