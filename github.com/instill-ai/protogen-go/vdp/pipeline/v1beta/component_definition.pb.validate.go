// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: vdp/pipeline/v1beta/component_definition.proto

package pipelinev1beta

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ComponentDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ComponentDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComponentDefinitionMultiError, or nil if none found.
func (m *ComponentDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for DocumentationUrl

	// no validation rules for Icon

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentDefinitionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentDefinitionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentDefinitionValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Tombstone

	// no validation rules for Public

	// no validation rules for Custom

	// no validation rules for Vendor

	if all {
		switch v := interface{}(m.GetVendorAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentDefinitionValidationError{
					field:  "VendorAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentDefinitionValidationError{
					field:  "VendorAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVendorAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentDefinitionValidationError{
				field:  "VendorAttributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SourceUrl

	// no validation rules for Version

	for idx, item := range m.GetTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComponentDefinitionValidationError{
						field:  fmt.Sprintf("Tasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComponentDefinitionValidationError{
						field:  fmt.Sprintf("Tasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComponentDefinitionValidationError{
					field:  fmt.Sprintf("Tasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Description

	// no validation rules for ReleaseStage

	if len(errors) > 0 {
		return ComponentDefinitionMultiError(errors)
	}

	return nil
}

// ComponentDefinitionMultiError is an error wrapping multiple validation
// errors returned by ComponentDefinition.ValidateAll() if the designated
// constraints aren't met.
type ComponentDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentDefinitionMultiError) AllErrors() []error { return m }

// ComponentDefinitionValidationError is the validation error returned by
// ComponentDefinition.Validate if the designated constraints aren't met.
type ComponentDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentDefinitionValidationError) ErrorName() string {
	return "ComponentDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e ComponentDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentDefinitionValidationError{}

// Validate checks the field values on DataSpecification with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DataSpecification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataSpecification with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataSpecificationMultiError, or nil if none found.
func (m *DataSpecification) ValidateAll() error {
	return m.validate(true)
}

func (m *DataSpecification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataSpecificationValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataSpecificationValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataSpecificationValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataSpecificationValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataSpecificationValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataSpecificationValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DataSpecificationMultiError(errors)
	}

	return nil
}

// DataSpecificationMultiError is an error wrapping multiple validation errors
// returned by DataSpecification.ValidateAll() if the designated constraints
// aren't met.
type DataSpecificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataSpecificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataSpecificationMultiError) AllErrors() []error { return m }

// DataSpecificationValidationError is the validation error returned by
// DataSpecification.Validate if the designated constraints aren't met.
type DataSpecificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataSpecificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataSpecificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataSpecificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataSpecificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataSpecificationValidationError) ErrorName() string {
	return "DataSpecificationValidationError"
}

// Error satisfies the builtin error interface
func (e DataSpecificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataSpecification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataSpecificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataSpecificationValidationError{}

// Validate checks the field values on ConnectorSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorSpecMultiError, or
// nil if none found.
func (m *ConnectorSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetComponentSpecification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorSpecValidationError{
					field:  "ComponentSpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorSpecValidationError{
					field:  "ComponentSpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComponentSpecification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorSpecValidationError{
				field:  "ComponentSpecification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetDataSpecifications()))
		i := 0
		for key := range m.GetDataSpecifications() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDataSpecifications()[key]
			_ = val

			// no validation rules for DataSpecifications[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ConnectorSpecValidationError{
							field:  fmt.Sprintf("DataSpecifications[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ConnectorSpecValidationError{
							field:  fmt.Sprintf("DataSpecifications[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ConnectorSpecValidationError{
						field:  fmt.Sprintf("DataSpecifications[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ConnectorSpecMultiError(errors)
	}

	return nil
}

// ConnectorSpecMultiError is an error wrapping multiple validation errors
// returned by ConnectorSpec.ValidateAll() if the designated constraints
// aren't met.
type ConnectorSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorSpecMultiError) AllErrors() []error { return m }

// ConnectorSpecValidationError is the validation error returned by
// ConnectorSpec.Validate if the designated constraints aren't met.
type ConnectorSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorSpecValidationError) ErrorName() string { return "ConnectorSpecValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorSpecValidationError{}

// Validate checks the field values on ConnectorDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectorDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectorDefinitionMultiError, or nil if none found.
func (m *ConnectorDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for DocumentationUrl

	// no validation rules for Icon

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorDefinitionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorDefinitionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorDefinitionValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Tombstone

	// no validation rules for Public

	// no validation rules for Custom

	// no validation rules for Vendor

	if all {
		switch v := interface{}(m.GetVendorAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorDefinitionValidationError{
					field:  "VendorAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorDefinitionValidationError{
					field:  "VendorAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVendorAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorDefinitionValidationError{
				field:  "VendorAttributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SourceUrl

	// no validation rules for Version

	for idx, item := range m.GetTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectorDefinitionValidationError{
						field:  fmt.Sprintf("Tasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectorDefinitionValidationError{
						field:  fmt.Sprintf("Tasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectorDefinitionValidationError{
					field:  fmt.Sprintf("Tasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Description

	// no validation rules for ReleaseStage

	if len(errors) > 0 {
		return ConnectorDefinitionMultiError(errors)
	}

	return nil
}

// ConnectorDefinitionMultiError is an error wrapping multiple validation
// errors returned by ConnectorDefinition.ValidateAll() if the designated
// constraints aren't met.
type ConnectorDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorDefinitionMultiError) AllErrors() []error { return m }

// ConnectorDefinitionValidationError is the validation error returned by
// ConnectorDefinition.Validate if the designated constraints aren't met.
type ConnectorDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorDefinitionValidationError) ErrorName() string {
	return "ConnectorDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectorDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorDefinitionValidationError{}

// Validate checks the field values on OperatorSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperatorSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperatorSpecMultiError, or
// nil if none found.
func (m *OperatorSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetComponentSpecification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSpecValidationError{
					field:  "ComponentSpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSpecValidationError{
					field:  "ComponentSpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComponentSpecification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSpecValidationError{
				field:  "ComponentSpecification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetDataSpecifications()))
		i := 0
		for key := range m.GetDataSpecifications() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDataSpecifications()[key]
			_ = val

			// no validation rules for DataSpecifications[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, OperatorSpecValidationError{
							field:  fmt.Sprintf("DataSpecifications[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, OperatorSpecValidationError{
							field:  fmt.Sprintf("DataSpecifications[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return OperatorSpecValidationError{
						field:  fmt.Sprintf("DataSpecifications[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return OperatorSpecMultiError(errors)
	}

	return nil
}

// OperatorSpecMultiError is an error wrapping multiple validation errors
// returned by OperatorSpec.ValidateAll() if the designated constraints aren't met.
type OperatorSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSpecMultiError) AllErrors() []error { return m }

// OperatorSpecValidationError is the validation error returned by
// OperatorSpec.Validate if the designated constraints aren't met.
type OperatorSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSpecValidationError) ErrorName() string { return "OperatorSpecValidationError" }

// Error satisfies the builtin error interface
func (e OperatorSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSpecValidationError{}

// Validate checks the field values on OperatorDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorDefinitionMultiError, or nil if none found.
func (m *OperatorDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for DocumentationUrl

	// no validation rules for Icon

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorDefinitionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorDefinitionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorDefinitionValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Tombstone

	// no validation rules for Public

	// no validation rules for Custom

	// no validation rules for SourceUrl

	// no validation rules for Version

	for idx, item := range m.GetTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperatorDefinitionValidationError{
						field:  fmt.Sprintf("Tasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperatorDefinitionValidationError{
						field:  fmt.Sprintf("Tasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperatorDefinitionValidationError{
					field:  fmt.Sprintf("Tasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Description

	// no validation rules for ReleaseStage

	if len(errors) > 0 {
		return OperatorDefinitionMultiError(errors)
	}

	return nil
}

// OperatorDefinitionMultiError is an error wrapping multiple validation errors
// returned by OperatorDefinition.ValidateAll() if the designated constraints
// aren't met.
type OperatorDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorDefinitionMultiError) AllErrors() []error { return m }

// OperatorDefinitionValidationError is the validation error returned by
// OperatorDefinition.Validate if the designated constraints aren't met.
type OperatorDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorDefinitionValidationError) ErrorName() string {
	return "OperatorDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorDefinitionValidationError{}

// Validate checks the field values on ListComponentDefinitionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListComponentDefinitionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListComponentDefinitionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListComponentDefinitionsRequestMultiError, or nil if none found.
func (m *ListComponentDefinitionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListComponentDefinitionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.View != nil {
		// no validation rules for View
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if len(errors) > 0 {
		return ListComponentDefinitionsRequestMultiError(errors)
	}

	return nil
}

// ListComponentDefinitionsRequestMultiError is an error wrapping multiple
// validation errors returned by ListComponentDefinitionsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListComponentDefinitionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListComponentDefinitionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListComponentDefinitionsRequestMultiError) AllErrors() []error { return m }

// ListComponentDefinitionsRequestValidationError is the validation error
// returned by ListComponentDefinitionsRequest.Validate if the designated
// constraints aren't met.
type ListComponentDefinitionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListComponentDefinitionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListComponentDefinitionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListComponentDefinitionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListComponentDefinitionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListComponentDefinitionsRequestValidationError) ErrorName() string {
	return "ListComponentDefinitionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListComponentDefinitionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListComponentDefinitionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListComponentDefinitionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListComponentDefinitionsRequestValidationError{}

// Validate checks the field values on ListComponentDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListComponentDefinitionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListComponentDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListComponentDefinitionsResponseMultiError, or nil if none found.
func (m *ListComponentDefinitionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListComponentDefinitionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetComponentDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListComponentDefinitionsResponseValidationError{
						field:  fmt.Sprintf("ComponentDefinitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListComponentDefinitionsResponseValidationError{
						field:  fmt.Sprintf("ComponentDefinitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListComponentDefinitionsResponseValidationError{
					field:  fmt.Sprintf("ComponentDefinitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalSize

	// no validation rules for PageSize

	// no validation rules for Page

	if len(errors) > 0 {
		return ListComponentDefinitionsResponseMultiError(errors)
	}

	return nil
}

// ListComponentDefinitionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListComponentDefinitionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListComponentDefinitionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListComponentDefinitionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListComponentDefinitionsResponseMultiError) AllErrors() []error { return m }

// ListComponentDefinitionsResponseValidationError is the validation error
// returned by ListComponentDefinitionsResponse.Validate if the designated
// constraints aren't met.
type ListComponentDefinitionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListComponentDefinitionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListComponentDefinitionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListComponentDefinitionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListComponentDefinitionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListComponentDefinitionsResponseValidationError) ErrorName() string {
	return "ListComponentDefinitionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListComponentDefinitionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListComponentDefinitionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListComponentDefinitionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListComponentDefinitionsResponseValidationError{}

// Validate checks the field values on ListConnectorDefinitionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConnectorDefinitionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConnectorDefinitionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListConnectorDefinitionsRequestMultiError, or nil if none found.
func (m *ListConnectorDefinitionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConnectorDefinitionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.View != nil {
		// no validation rules for View
	}

	if len(errors) > 0 {
		return ListConnectorDefinitionsRequestMultiError(errors)
	}

	return nil
}

// ListConnectorDefinitionsRequestMultiError is an error wrapping multiple
// validation errors returned by ListConnectorDefinitionsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListConnectorDefinitionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConnectorDefinitionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConnectorDefinitionsRequestMultiError) AllErrors() []error { return m }

// ListConnectorDefinitionsRequestValidationError is the validation error
// returned by ListConnectorDefinitionsRequest.Validate if the designated
// constraints aren't met.
type ListConnectorDefinitionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConnectorDefinitionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConnectorDefinitionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConnectorDefinitionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConnectorDefinitionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConnectorDefinitionsRequestValidationError) ErrorName() string {
	return "ListConnectorDefinitionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListConnectorDefinitionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConnectorDefinitionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConnectorDefinitionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConnectorDefinitionsRequestValidationError{}

// Validate checks the field values on ListConnectorDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListConnectorDefinitionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConnectorDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListConnectorDefinitionsResponseMultiError, or nil if none found.
func (m *ListConnectorDefinitionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConnectorDefinitionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnectorDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListConnectorDefinitionsResponseValidationError{
						field:  fmt.Sprintf("ConnectorDefinitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListConnectorDefinitionsResponseValidationError{
						field:  fmt.Sprintf("ConnectorDefinitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListConnectorDefinitionsResponseValidationError{
					field:  fmt.Sprintf("ConnectorDefinitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	// no validation rules for TotalSize

	if len(errors) > 0 {
		return ListConnectorDefinitionsResponseMultiError(errors)
	}

	return nil
}

// ListConnectorDefinitionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListConnectorDefinitionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListConnectorDefinitionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConnectorDefinitionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConnectorDefinitionsResponseMultiError) AllErrors() []error { return m }

// ListConnectorDefinitionsResponseValidationError is the validation error
// returned by ListConnectorDefinitionsResponse.Validate if the designated
// constraints aren't met.
type ListConnectorDefinitionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConnectorDefinitionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConnectorDefinitionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConnectorDefinitionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConnectorDefinitionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConnectorDefinitionsResponseValidationError) ErrorName() string {
	return "ListConnectorDefinitionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListConnectorDefinitionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConnectorDefinitionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConnectorDefinitionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConnectorDefinitionsResponseValidationError{}

// Validate checks the field values on GetConnectorDefinitionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectorDefinitionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectorDefinitionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetConnectorDefinitionRequestMultiError, or nil if none found.
func (m *GetConnectorDefinitionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectorDefinitionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if m.View != nil {
		// no validation rules for View
	}

	if len(errors) > 0 {
		return GetConnectorDefinitionRequestMultiError(errors)
	}

	return nil
}

// GetConnectorDefinitionRequestMultiError is an error wrapping multiple
// validation errors returned by GetConnectorDefinitionRequest.ValidateAll()
// if the designated constraints aren't met.
type GetConnectorDefinitionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectorDefinitionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectorDefinitionRequestMultiError) AllErrors() []error { return m }

// GetConnectorDefinitionRequestValidationError is the validation error
// returned by GetConnectorDefinitionRequest.Validate if the designated
// constraints aren't met.
type GetConnectorDefinitionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectorDefinitionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectorDefinitionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectorDefinitionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectorDefinitionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectorDefinitionRequestValidationError) ErrorName() string {
	return "GetConnectorDefinitionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectorDefinitionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectorDefinitionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectorDefinitionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectorDefinitionRequestValidationError{}

// Validate checks the field values on GetConnectorDefinitionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectorDefinitionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectorDefinitionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetConnectorDefinitionResponseMultiError, or nil if none found.
func (m *GetConnectorDefinitionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectorDefinitionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnectorDefinition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConnectorDefinitionResponseValidationError{
					field:  "ConnectorDefinition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConnectorDefinitionResponseValidationError{
					field:  "ConnectorDefinition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectorDefinition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConnectorDefinitionResponseValidationError{
				field:  "ConnectorDefinition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConnectorDefinitionResponseMultiError(errors)
	}

	return nil
}

// GetConnectorDefinitionResponseMultiError is an error wrapping multiple
// validation errors returned by GetConnectorDefinitionResponse.ValidateAll()
// if the designated constraints aren't met.
type GetConnectorDefinitionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectorDefinitionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectorDefinitionResponseMultiError) AllErrors() []error { return m }

// GetConnectorDefinitionResponseValidationError is the validation error
// returned by GetConnectorDefinitionResponse.Validate if the designated
// constraints aren't met.
type GetConnectorDefinitionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectorDefinitionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectorDefinitionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectorDefinitionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectorDefinitionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectorDefinitionResponseValidationError) ErrorName() string {
	return "GetConnectorDefinitionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectorDefinitionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectorDefinitionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectorDefinitionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectorDefinitionResponseValidationError{}

// Validate checks the field values on ListOperatorDefinitionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperatorDefinitionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperatorDefinitionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListOperatorDefinitionsRequestMultiError, or nil if none found.
func (m *ListOperatorDefinitionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorDefinitionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if m.View != nil {
		// no validation rules for View
	}

	if len(errors) > 0 {
		return ListOperatorDefinitionsRequestMultiError(errors)
	}

	return nil
}

// ListOperatorDefinitionsRequestMultiError is an error wrapping multiple
// validation errors returned by ListOperatorDefinitionsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListOperatorDefinitionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorDefinitionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorDefinitionsRequestMultiError) AllErrors() []error { return m }

// ListOperatorDefinitionsRequestValidationError is the validation error
// returned by ListOperatorDefinitionsRequest.Validate if the designated
// constraints aren't met.
type ListOperatorDefinitionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorDefinitionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorDefinitionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorDefinitionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorDefinitionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorDefinitionsRequestValidationError) ErrorName() string {
	return "ListOperatorDefinitionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorDefinitionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorDefinitionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorDefinitionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorDefinitionsRequestValidationError{}

// Validate checks the field values on ListOperatorDefinitionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperatorDefinitionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperatorDefinitionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListOperatorDefinitionsResponseMultiError, or nil if none found.
func (m *ListOperatorDefinitionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorDefinitionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOperatorDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorDefinitionsResponseValidationError{
						field:  fmt.Sprintf("OperatorDefinitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorDefinitionsResponseValidationError{
						field:  fmt.Sprintf("OperatorDefinitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorDefinitionsResponseValidationError{
					field:  fmt.Sprintf("OperatorDefinitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	// no validation rules for TotalSize

	if len(errors) > 0 {
		return ListOperatorDefinitionsResponseMultiError(errors)
	}

	return nil
}

// ListOperatorDefinitionsResponseMultiError is an error wrapping multiple
// validation errors returned by ListOperatorDefinitionsResponse.ValidateAll()
// if the designated constraints aren't met.
type ListOperatorDefinitionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorDefinitionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorDefinitionsResponseMultiError) AllErrors() []error { return m }

// ListOperatorDefinitionsResponseValidationError is the validation error
// returned by ListOperatorDefinitionsResponse.Validate if the designated
// constraints aren't met.
type ListOperatorDefinitionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorDefinitionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorDefinitionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorDefinitionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorDefinitionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorDefinitionsResponseValidationError) ErrorName() string {
	return "ListOperatorDefinitionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorDefinitionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorDefinitionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorDefinitionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorDefinitionsResponseValidationError{}

// Validate checks the field values on GetOperatorDefinitionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperatorDefinitionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorDefinitionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOperatorDefinitionRequestMultiError, or nil if none found.
func (m *GetOperatorDefinitionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorDefinitionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if m.View != nil {
		// no validation rules for View
	}

	if len(errors) > 0 {
		return GetOperatorDefinitionRequestMultiError(errors)
	}

	return nil
}

// GetOperatorDefinitionRequestMultiError is an error wrapping multiple
// validation errors returned by GetOperatorDefinitionRequest.ValidateAll() if
// the designated constraints aren't met.
type GetOperatorDefinitionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorDefinitionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorDefinitionRequestMultiError) AllErrors() []error { return m }

// GetOperatorDefinitionRequestValidationError is the validation error returned
// by GetOperatorDefinitionRequest.Validate if the designated constraints
// aren't met.
type GetOperatorDefinitionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorDefinitionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorDefinitionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorDefinitionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorDefinitionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorDefinitionRequestValidationError) ErrorName() string {
	return "GetOperatorDefinitionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorDefinitionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorDefinitionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorDefinitionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorDefinitionRequestValidationError{}

// Validate checks the field values on GetOperatorDefinitionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperatorDefinitionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorDefinitionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetOperatorDefinitionResponseMultiError, or nil if none found.
func (m *GetOperatorDefinitionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorDefinitionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorDefinition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOperatorDefinitionResponseValidationError{
					field:  "OperatorDefinition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOperatorDefinitionResponseValidationError{
					field:  "OperatorDefinition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorDefinition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOperatorDefinitionResponseValidationError{
				field:  "OperatorDefinition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOperatorDefinitionResponseMultiError(errors)
	}

	return nil
}

// GetOperatorDefinitionResponseMultiError is an error wrapping multiple
// validation errors returned by GetOperatorDefinitionResponse.ValidateAll()
// if the designated constraints aren't met.
type GetOperatorDefinitionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorDefinitionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorDefinitionResponseMultiError) AllErrors() []error { return m }

// GetOperatorDefinitionResponseValidationError is the validation error
// returned by GetOperatorDefinitionResponse.Validate if the designated
// constraints aren't met.
type GetOperatorDefinitionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorDefinitionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorDefinitionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorDefinitionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorDefinitionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorDefinitionResponseValidationError) ErrorName() string {
	return "GetOperatorDefinitionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorDefinitionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorDefinitionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorDefinitionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorDefinitionResponseValidationError{}

// Validate checks the field values on ComponentDefinition_Spec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ComponentDefinition_Spec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentDefinition_Spec with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComponentDefinition_SpecMultiError, or nil if none found.
func (m *ComponentDefinition_Spec) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentDefinition_Spec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetComponentSpecification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentDefinition_SpecValidationError{
					field:  "ComponentSpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentDefinition_SpecValidationError{
					field:  "ComponentSpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComponentSpecification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentDefinition_SpecValidationError{
				field:  "ComponentSpecification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetDataSpecifications()))
		i := 0
		for key := range m.GetDataSpecifications() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDataSpecifications()[key]
			_ = val

			// no validation rules for DataSpecifications[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ComponentDefinition_SpecValidationError{
							field:  fmt.Sprintf("DataSpecifications[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ComponentDefinition_SpecValidationError{
							field:  fmt.Sprintf("DataSpecifications[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ComponentDefinition_SpecValidationError{
						field:  fmt.Sprintf("DataSpecifications[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ComponentDefinition_SpecMultiError(errors)
	}

	return nil
}

// ComponentDefinition_SpecMultiError is an error wrapping multiple validation
// errors returned by ComponentDefinition_Spec.ValidateAll() if the designated
// constraints aren't met.
type ComponentDefinition_SpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentDefinition_SpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentDefinition_SpecMultiError) AllErrors() []error { return m }

// ComponentDefinition_SpecValidationError is the validation error returned by
// ComponentDefinition_Spec.Validate if the designated constraints aren't met.
type ComponentDefinition_SpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentDefinition_SpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentDefinition_SpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentDefinition_SpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentDefinition_SpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentDefinition_SpecValidationError) ErrorName() string {
	return "ComponentDefinition_SpecValidationError"
}

// Error satisfies the builtin error interface
func (e ComponentDefinition_SpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentDefinition_Spec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentDefinition_SpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentDefinition_SpecValidationError{}
