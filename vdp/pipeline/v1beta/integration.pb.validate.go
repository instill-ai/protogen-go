// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: vdp/pipeline/v1beta/integration.proto

package pipelinev1beta

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _integration_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on Connection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectionMultiError, or
// nil if none found.
func (m *Connection) ValidateAll() error {
	return m.validate(true)
}

func (m *Connection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() != "" {

		if err := m._validateUuid(m.GetUid()); err != nil {
			err = ConnectionValidationError{
				field:  "Uid",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Id

	// no validation rules for NamespaceId

	// no validation rules for IntegrationId

	// no validation rules for IntegrationTitle

	// no validation rules for Method

	if all {
		switch v := interface{}(m.GetSetup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "Setup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "Setup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "Setup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for View

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OAuthAccessDetails != nil {

		if all {
			switch v := interface{}(m.GetOAuthAccessDetails()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionValidationError{
						field:  "OAuthAccessDetails",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionValidationError{
						field:  "OAuthAccessDetails",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOAuthAccessDetails()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionValidationError{
					field:  "OAuthAccessDetails",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConnectionMultiError(errors)
	}

	return nil
}

func (m *Connection) _validateUuid(uuid string) error {
	if matched := _integration_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ConnectionMultiError is an error wrapping multiple validation errors
// returned by Connection.ValidateAll() if the designated constraints aren't met.
type ConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionMultiError) AllErrors() []error { return m }

// ConnectionValidationError is the validation error returned by
// Connection.Validate if the designated constraints aren't met.
type ConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionValidationError) ErrorName() string { return "ConnectionValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionValidationError{}

// Validate checks the field values on ListNamespaceConnectionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNamespaceConnectionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceConnectionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespaceConnectionsRequestMultiError, or nil if none found.
func (m *ListNamespaceConnectionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceConnectionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if len(errors) > 0 {
		return ListNamespaceConnectionsRequestMultiError(errors)
	}

	return nil
}

// ListNamespaceConnectionsRequestMultiError is an error wrapping multiple
// validation errors returned by ListNamespaceConnectionsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListNamespaceConnectionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceConnectionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceConnectionsRequestMultiError) AllErrors() []error { return m }

// ListNamespaceConnectionsRequestValidationError is the validation error
// returned by ListNamespaceConnectionsRequest.Validate if the designated
// constraints aren't met.
type ListNamespaceConnectionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceConnectionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceConnectionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceConnectionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceConnectionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceConnectionsRequestValidationError) ErrorName() string {
	return "ListNamespaceConnectionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceConnectionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceConnectionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceConnectionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceConnectionsRequestValidationError{}

// Validate checks the field values on ListNamespaceConnectionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListNamespaceConnectionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNamespaceConnectionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNamespaceConnectionsResponseMultiError, or nil if none found.
func (m *ListNamespaceConnectionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNamespaceConnectionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNamespaceConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNamespaceConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNamespaceConnectionsResponseValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	// no validation rules for TotalSize

	if len(errors) > 0 {
		return ListNamespaceConnectionsResponseMultiError(errors)
	}

	return nil
}

// ListNamespaceConnectionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListNamespaceConnectionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNamespaceConnectionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNamespaceConnectionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNamespaceConnectionsResponseMultiError) AllErrors() []error { return m }

// ListNamespaceConnectionsResponseValidationError is the validation error
// returned by ListNamespaceConnectionsResponse.Validate if the designated
// constraints aren't met.
type ListNamespaceConnectionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNamespaceConnectionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNamespaceConnectionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNamespaceConnectionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNamespaceConnectionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNamespaceConnectionsResponseValidationError) ErrorName() string {
	return "ListNamespaceConnectionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNamespaceConnectionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNamespaceConnectionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNamespaceConnectionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNamespaceConnectionsResponseValidationError{}

// Validate checks the field values on GetNamespaceConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetNamespaceConnectionRequestMultiError, or nil if none found.
func (m *GetNamespaceConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for ConnectionId

	if m.View != nil {
		// no validation rules for View
	}

	if len(errors) > 0 {
		return GetNamespaceConnectionRequestMultiError(errors)
	}

	return nil
}

// GetNamespaceConnectionRequestMultiError is an error wrapping multiple
// validation errors returned by GetNamespaceConnectionRequest.ValidateAll()
// if the designated constraints aren't met.
type GetNamespaceConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceConnectionRequestMultiError) AllErrors() []error { return m }

// GetNamespaceConnectionRequestValidationError is the validation error
// returned by GetNamespaceConnectionRequest.Validate if the designated
// constraints aren't met.
type GetNamespaceConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceConnectionRequestValidationError) ErrorName() string {
	return "GetNamespaceConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceConnectionRequestValidationError{}

// Validate checks the field values on GetNamespaceConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNamespaceConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNamespaceConnectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetNamespaceConnectionResponseMultiError, or nil if none found.
func (m *GetNamespaceConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNamespaceConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNamespaceConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNamespaceConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNamespaceConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNamespaceConnectionResponseMultiError(errors)
	}

	return nil
}

// GetNamespaceConnectionResponseMultiError is an error wrapping multiple
// validation errors returned by GetNamespaceConnectionResponse.ValidateAll()
// if the designated constraints aren't met.
type GetNamespaceConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNamespaceConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNamespaceConnectionResponseMultiError) AllErrors() []error { return m }

// GetNamespaceConnectionResponseValidationError is the validation error
// returned by GetNamespaceConnectionResponse.Validate if the designated
// constraints aren't met.
type GetNamespaceConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNamespaceConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNamespaceConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNamespaceConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNamespaceConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNamespaceConnectionResponseValidationError) ErrorName() string {
	return "GetNamespaceConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNamespaceConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNamespaceConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNamespaceConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNamespaceConnectionResponseValidationError{}

// Validate checks the field values on CreateNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateNamespaceConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateNamespaceConnectionRequestMultiError, or nil if none found.
func (m *CreateNamespaceConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceConnectionRequestValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceConnectionRequestValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceConnectionRequestValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNamespaceConnectionRequestMultiError(errors)
	}

	return nil
}

// CreateNamespaceConnectionRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateNamespaceConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceConnectionRequestMultiError) AllErrors() []error { return m }

// CreateNamespaceConnectionRequestValidationError is the validation error
// returned by CreateNamespaceConnectionRequest.Validate if the designated
// constraints aren't met.
type CreateNamespaceConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceConnectionRequestValidationError) ErrorName() string {
	return "CreateNamespaceConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceConnectionRequestValidationError{}

// Validate checks the field values on CreateNamespaceConnectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateNamespaceConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNamespaceConnectionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateNamespaceConnectionResponseMultiError, or nil if none found.
func (m *CreateNamespaceConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNamespaceConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNamespaceConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNamespaceConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNamespaceConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNamespaceConnectionResponseMultiError(errors)
	}

	return nil
}

// CreateNamespaceConnectionResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateNamespaceConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateNamespaceConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNamespaceConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNamespaceConnectionResponseMultiError) AllErrors() []error { return m }

// CreateNamespaceConnectionResponseValidationError is the validation error
// returned by CreateNamespaceConnectionResponse.Validate if the designated
// constraints aren't met.
type CreateNamespaceConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNamespaceConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNamespaceConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNamespaceConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNamespaceConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNamespaceConnectionResponseValidationError) ErrorName() string {
	return "CreateNamespaceConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNamespaceConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNamespaceConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNamespaceConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNamespaceConnectionResponseValidationError{}

// Validate checks the field values on UpdateNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateNamespaceConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNamespaceConnectionRequestMultiError, or nil if none found.
func (m *UpdateNamespaceConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConnectionId

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNamespaceConnectionRequestValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNamespaceConnectionRequestValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNamespaceConnectionRequestValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNamespaceConnectionRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNamespaceConnectionRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNamespaceConnectionRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNamespaceConnectionRequestMultiError(errors)
	}

	return nil
}

// UpdateNamespaceConnectionRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateNamespaceConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceConnectionRequestMultiError) AllErrors() []error { return m }

// UpdateNamespaceConnectionRequestValidationError is the validation error
// returned by UpdateNamespaceConnectionRequest.Validate if the designated
// constraints aren't met.
type UpdateNamespaceConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceConnectionRequestValidationError) ErrorName() string {
	return "UpdateNamespaceConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceConnectionRequestValidationError{}

// Validate checks the field values on UpdateNamespaceConnectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateNamespaceConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNamespaceConnectionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateNamespaceConnectionResponseMultiError, or nil if none found.
func (m *UpdateNamespaceConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNamespaceConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNamespaceConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNamespaceConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNamespaceConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNamespaceConnectionResponseMultiError(errors)
	}

	return nil
}

// UpdateNamespaceConnectionResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateNamespaceConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNamespaceConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNamespaceConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNamespaceConnectionResponseMultiError) AllErrors() []error { return m }

// UpdateNamespaceConnectionResponseValidationError is the validation error
// returned by UpdateNamespaceConnectionResponse.Validate if the designated
// constraints aren't met.
type UpdateNamespaceConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNamespaceConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNamespaceConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNamespaceConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNamespaceConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNamespaceConnectionResponseValidationError) ErrorName() string {
	return "UpdateNamespaceConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNamespaceConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNamespaceConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNamespaceConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNamespaceConnectionResponseValidationError{}

// Validate checks the field values on DeleteNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteNamespaceConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNamespaceConnectionRequestMultiError, or nil if none found.
func (m *DeleteNamespaceConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for ConnectionId

	if len(errors) > 0 {
		return DeleteNamespaceConnectionRequestMultiError(errors)
	}

	return nil
}

// DeleteNamespaceConnectionRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteNamespaceConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceConnectionRequestMultiError) AllErrors() []error { return m }

// DeleteNamespaceConnectionRequestValidationError is the validation error
// returned by DeleteNamespaceConnectionRequest.Validate if the designated
// constraints aren't met.
type DeleteNamespaceConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceConnectionRequestValidationError) ErrorName() string {
	return "DeleteNamespaceConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceConnectionRequestValidationError{}

// Validate checks the field values on DeleteNamespaceConnectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteNamespaceConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNamespaceConnectionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteNamespaceConnectionResponseMultiError, or nil if none found.
func (m *DeleteNamespaceConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNamespaceConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteNamespaceConnectionResponseMultiError(errors)
	}

	return nil
}

// DeleteNamespaceConnectionResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteNamespaceConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNamespaceConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNamespaceConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNamespaceConnectionResponseMultiError) AllErrors() []error { return m }

// DeleteNamespaceConnectionResponseValidationError is the validation error
// returned by DeleteNamespaceConnectionResponse.Validate if the designated
// constraints aren't met.
type DeleteNamespaceConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNamespaceConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNamespaceConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNamespaceConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNamespaceConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNamespaceConnectionResponseValidationError) ErrorName() string {
	return "DeleteNamespaceConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNamespaceConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNamespaceConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNamespaceConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNamespaceConnectionResponseValidationError{}

// Validate checks the field values on TestNamespaceConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestNamespaceConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestNamespaceConnectionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TestNamespaceConnectionRequestMultiError, or nil if none found.
func (m *TestNamespaceConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestNamespaceConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for ConnectionId

	if len(errors) > 0 {
		return TestNamespaceConnectionRequestMultiError(errors)
	}

	return nil
}

// TestNamespaceConnectionRequestMultiError is an error wrapping multiple
// validation errors returned by TestNamespaceConnectionRequest.ValidateAll()
// if the designated constraints aren't met.
type TestNamespaceConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestNamespaceConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestNamespaceConnectionRequestMultiError) AllErrors() []error { return m }

// TestNamespaceConnectionRequestValidationError is the validation error
// returned by TestNamespaceConnectionRequest.Validate if the designated
// constraints aren't met.
type TestNamespaceConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestNamespaceConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestNamespaceConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestNamespaceConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestNamespaceConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestNamespaceConnectionRequestValidationError) ErrorName() string {
	return "TestNamespaceConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestNamespaceConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestNamespaceConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestNamespaceConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestNamespaceConnectionRequestValidationError{}

// Validate checks the field values on TestNamespaceConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestNamespaceConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestNamespaceConnectionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TestNamespaceConnectionResponseMultiError, or nil if none found.
func (m *TestNamespaceConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestNamespaceConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestNamespaceConnectionResponseMultiError(errors)
	}

	return nil
}

// TestNamespaceConnectionResponseMultiError is an error wrapping multiple
// validation errors returned by TestNamespaceConnectionResponse.ValidateAll()
// if the designated constraints aren't met.
type TestNamespaceConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestNamespaceConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestNamespaceConnectionResponseMultiError) AllErrors() []error { return m }

// TestNamespaceConnectionResponseValidationError is the validation error
// returned by TestNamespaceConnectionResponse.Validate if the designated
// constraints aren't met.
type TestNamespaceConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestNamespaceConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestNamespaceConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestNamespaceConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestNamespaceConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestNamespaceConnectionResponseValidationError) ErrorName() string {
	return "TestNamespaceConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestNamespaceConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestNamespaceConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestNamespaceConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestNamespaceConnectionResponseValidationError{}

// Validate checks the field values on Integration with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Integration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integration with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IntegrationMultiError, or
// nil if none found.
func (m *Integration) ValidateAll() error {
	return m.validate(true)
}

func (m *Integration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUid()); err != nil {
		err = IntegrationValidationError{
			field:  "Uid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for Vendor

	// no validation rules for Icon

	if all {
		switch v := interface{}(m.GetSetupSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntegrationValidationError{
					field:  "SetupSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntegrationValidationError{
					field:  "SetupSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetupSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntegrationValidationError{
				field:  "SetupSchema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for View

	for idx, item := range m.GetSchemas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IntegrationValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IntegrationValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IntegrationValidationError{
					field:  fmt.Sprintf("Schemas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.HelpLink != nil {

		if all {
			switch v := interface{}(m.GetHelpLink()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IntegrationValidationError{
						field:  "HelpLink",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IntegrationValidationError{
						field:  "HelpLink",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHelpLink()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IntegrationValidationError{
					field:  "HelpLink",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OAuthConfig != nil {

		if all {
			switch v := interface{}(m.GetOAuthConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IntegrationValidationError{
						field:  "OAuthConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IntegrationValidationError{
						field:  "OAuthConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOAuthConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IntegrationValidationError{
					field:  "OAuthConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IntegrationMultiError(errors)
	}

	return nil
}

func (m *Integration) _validateUuid(uuid string) error {
	if matched := _integration_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// IntegrationMultiError is an error wrapping multiple validation errors
// returned by Integration.ValidateAll() if the designated constraints aren't met.
type IntegrationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IntegrationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IntegrationMultiError) AllErrors() []error { return m }

// IntegrationValidationError is the validation error returned by
// Integration.Validate if the designated constraints aren't met.
type IntegrationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IntegrationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IntegrationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IntegrationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IntegrationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IntegrationValidationError) ErrorName() string { return "IntegrationValidationError" }

// Error satisfies the builtin error interface
func (e IntegrationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IntegrationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IntegrationValidationError{}

// Validate checks the field values on ListPipelineIDsByConnectionIDRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListPipelineIDsByConnectionIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPipelineIDsByConnectionIDRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListPipelineIDsByConnectionIDRequestMultiError, or nil if none found.
func (m *ListPipelineIDsByConnectionIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPipelineIDsByConnectionIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamespaceId

	// no validation rules for ConnectionId

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if len(errors) > 0 {
		return ListPipelineIDsByConnectionIDRequestMultiError(errors)
	}

	return nil
}

// ListPipelineIDsByConnectionIDRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListPipelineIDsByConnectionIDRequest.ValidateAll() if the designated
// constraints aren't met.
type ListPipelineIDsByConnectionIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPipelineIDsByConnectionIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPipelineIDsByConnectionIDRequestMultiError) AllErrors() []error { return m }

// ListPipelineIDsByConnectionIDRequestValidationError is the validation error
// returned by ListPipelineIDsByConnectionIDRequest.Validate if the designated
// constraints aren't met.
type ListPipelineIDsByConnectionIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPipelineIDsByConnectionIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPipelineIDsByConnectionIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPipelineIDsByConnectionIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPipelineIDsByConnectionIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPipelineIDsByConnectionIDRequestValidationError) ErrorName() string {
	return "ListPipelineIDsByConnectionIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPipelineIDsByConnectionIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPipelineIDsByConnectionIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPipelineIDsByConnectionIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPipelineIDsByConnectionIDRequestValidationError{}

// Validate checks the field values on ListPipelineIDsByConnectionIDResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListPipelineIDsByConnectionIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPipelineIDsByConnectionIDResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListPipelineIDsByConnectionIDResponseMultiError, or nil if none found.
func (m *ListPipelineIDsByConnectionIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPipelineIDsByConnectionIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextPageToken

	// no validation rules for TotalSize

	if len(errors) > 0 {
		return ListPipelineIDsByConnectionIDResponseMultiError(errors)
	}

	return nil
}

// ListPipelineIDsByConnectionIDResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListPipelineIDsByConnectionIDResponse.ValidateAll() if the designated
// constraints aren't met.
type ListPipelineIDsByConnectionIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPipelineIDsByConnectionIDResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPipelineIDsByConnectionIDResponseMultiError) AllErrors() []error { return m }

// ListPipelineIDsByConnectionIDResponseValidationError is the validation error
// returned by ListPipelineIDsByConnectionIDResponse.Validate if the
// designated constraints aren't met.
type ListPipelineIDsByConnectionIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPipelineIDsByConnectionIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPipelineIDsByConnectionIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPipelineIDsByConnectionIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPipelineIDsByConnectionIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPipelineIDsByConnectionIDResponseValidationError) ErrorName() string {
	return "ListPipelineIDsByConnectionIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPipelineIDsByConnectionIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPipelineIDsByConnectionIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPipelineIDsByConnectionIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPipelineIDsByConnectionIDResponseValidationError{}

// Validate checks the field values on ListIntegrationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListIntegrationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListIntegrationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListIntegrationsRequestMultiError, or nil if none found.
func (m *ListIntegrationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListIntegrationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.Filter != nil {
		// no validation rules for Filter
	}

	if len(errors) > 0 {
		return ListIntegrationsRequestMultiError(errors)
	}

	return nil
}

// ListIntegrationsRequestMultiError is an error wrapping multiple validation
// errors returned by ListIntegrationsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListIntegrationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIntegrationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIntegrationsRequestMultiError) AllErrors() []error { return m }

// ListIntegrationsRequestValidationError is the validation error returned by
// ListIntegrationsRequest.Validate if the designated constraints aren't met.
type ListIntegrationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIntegrationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIntegrationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIntegrationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIntegrationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIntegrationsRequestValidationError) ErrorName() string {
	return "ListIntegrationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListIntegrationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIntegrationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIntegrationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIntegrationsRequestValidationError{}

// Validate checks the field values on ListIntegrationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListIntegrationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListIntegrationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListIntegrationsResponseMultiError, or nil if none found.
func (m *ListIntegrationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListIntegrationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIntegrations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListIntegrationsResponseValidationError{
						field:  fmt.Sprintf("Integrations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListIntegrationsResponseValidationError{
						field:  fmt.Sprintf("Integrations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListIntegrationsResponseValidationError{
					field:  fmt.Sprintf("Integrations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	// no validation rules for TotalSize

	if len(errors) > 0 {
		return ListIntegrationsResponseMultiError(errors)
	}

	return nil
}

// ListIntegrationsResponseMultiError is an error wrapping multiple validation
// errors returned by ListIntegrationsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListIntegrationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIntegrationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIntegrationsResponseMultiError) AllErrors() []error { return m }

// ListIntegrationsResponseValidationError is the validation error returned by
// ListIntegrationsResponse.Validate if the designated constraints aren't met.
type ListIntegrationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIntegrationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIntegrationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIntegrationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIntegrationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIntegrationsResponseValidationError) ErrorName() string {
	return "ListIntegrationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListIntegrationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIntegrationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIntegrationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIntegrationsResponseValidationError{}

// Validate checks the field values on GetIntegrationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationRequestMultiError, or nil if none found.
func (m *GetIntegrationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IntegrationId

	if m.View != nil {
		// no validation rules for View
	}

	if len(errors) > 0 {
		return GetIntegrationRequestMultiError(errors)
	}

	return nil
}

// GetIntegrationRequestMultiError is an error wrapping multiple validation
// errors returned by GetIntegrationRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIntegrationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationRequestMultiError) AllErrors() []error { return m }

// GetIntegrationRequestValidationError is the validation error returned by
// GetIntegrationRequest.Validate if the designated constraints aren't met.
type GetIntegrationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationRequestValidationError) ErrorName() string {
	return "GetIntegrationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationRequestValidationError{}

// Validate checks the field values on GetIntegrationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntegrationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntegrationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntegrationResponseMultiError, or nil if none found.
func (m *GetIntegrationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntegrationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIntegration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIntegrationResponseValidationError{
					field:  "Integration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIntegrationResponseValidationError{
					field:  "Integration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntegration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIntegrationResponseValidationError{
				field:  "Integration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIntegrationResponseMultiError(errors)
	}

	return nil
}

// GetIntegrationResponseMultiError is an error wrapping multiple validation
// errors returned by GetIntegrationResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIntegrationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntegrationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntegrationResponseMultiError) AllErrors() []error { return m }

// GetIntegrationResponseValidationError is the validation error returned by
// GetIntegrationResponse.Validate if the designated constraints aren't met.
type GetIntegrationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntegrationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntegrationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntegrationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntegrationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntegrationResponseValidationError) ErrorName() string {
	return "GetIntegrationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntegrationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntegrationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntegrationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntegrationResponseValidationError{}

// Validate checks the field values on Integration_Link with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Integration_Link) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integration_Link with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Integration_LinkMultiError, or nil if none found.
func (m *Integration_Link) ValidateAll() error {
	return m.validate(true)
}

func (m *Integration_Link) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Text

	// no validation rules for Url

	if len(errors) > 0 {
		return Integration_LinkMultiError(errors)
	}

	return nil
}

// Integration_LinkMultiError is an error wrapping multiple validation errors
// returned by Integration_Link.ValidateAll() if the designated constraints
// aren't met.
type Integration_LinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Integration_LinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Integration_LinkMultiError) AllErrors() []error { return m }

// Integration_LinkValidationError is the validation error returned by
// Integration_Link.Validate if the designated constraints aren't met.
type Integration_LinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Integration_LinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Integration_LinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Integration_LinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Integration_LinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Integration_LinkValidationError) ErrorName() string { return "Integration_LinkValidationError" }

// Error satisfies the builtin error interface
func (e Integration_LinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegration_Link.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Integration_LinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Integration_LinkValidationError{}

// Validate checks the field values on Integration_OAuthConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Integration_OAuthConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integration_OAuthConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Integration_OAuthConfigMultiError, or nil if none found.
func (m *Integration_OAuthConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *Integration_OAuthConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if uri, err := url.Parse(m.GetAuthUrl()); err != nil {
		err = Integration_OAuthConfigValidationError{
			field:  "AuthUrl",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := Integration_OAuthConfigValidationError{
			field:  "AuthUrl",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetAccessUrl()); err != nil {
		err = Integration_OAuthConfigValidationError{
			field:  "AccessUrl",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := Integration_OAuthConfigValidationError{
			field:  "AccessUrl",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Integration_OAuthConfigMultiError(errors)
	}

	return nil
}

// Integration_OAuthConfigMultiError is an error wrapping multiple validation
// errors returned by Integration_OAuthConfig.ValidateAll() if the designated
// constraints aren't met.
type Integration_OAuthConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Integration_OAuthConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Integration_OAuthConfigMultiError) AllErrors() []error { return m }

// Integration_OAuthConfigValidationError is the validation error returned by
// Integration_OAuthConfig.Validate if the designated constraints aren't met.
type Integration_OAuthConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Integration_OAuthConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Integration_OAuthConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Integration_OAuthConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Integration_OAuthConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Integration_OAuthConfigValidationError) ErrorName() string {
	return "Integration_OAuthConfigValidationError"
}

// Error satisfies the builtin error interface
func (e Integration_OAuthConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegration_OAuthConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Integration_OAuthConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Integration_OAuthConfigValidationError{}

// Validate checks the field values on Integration_SetupSchema with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Integration_SetupSchema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Integration_SetupSchema with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Integration_SetupSchemaMultiError, or nil if none found.
func (m *Integration_SetupSchema) ValidateAll() error {
	return m.validate(true)
}

func (m *Integration_SetupSchema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Method

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Integration_SetupSchemaValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Integration_SetupSchemaValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Integration_SetupSchemaValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Integration_SetupSchemaMultiError(errors)
	}

	return nil
}

// Integration_SetupSchemaMultiError is an error wrapping multiple validation
// errors returned by Integration_SetupSchema.ValidateAll() if the designated
// constraints aren't met.
type Integration_SetupSchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Integration_SetupSchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Integration_SetupSchemaMultiError) AllErrors() []error { return m }

// Integration_SetupSchemaValidationError is the validation error returned by
// Integration_SetupSchema.Validate if the designated constraints aren't met.
type Integration_SetupSchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Integration_SetupSchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Integration_SetupSchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Integration_SetupSchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Integration_SetupSchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Integration_SetupSchemaValidationError) ErrorName() string {
	return "Integration_SetupSchemaValidationError"
}

// Error satisfies the builtin error interface
func (e Integration_SetupSchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntegration_SetupSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Integration_SetupSchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Integration_SetupSchemaValidationError{}
