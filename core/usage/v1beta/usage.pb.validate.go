// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: core/usage/v1beta/usage.proto

package usagev1beta

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	mgmtv1beta "github.com/instill-ai/protogen-go/core/mgmt/v1beta"

	taskv1alpha "github.com/instill-ai/protogen-go/common/task/v1alpha"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = mgmtv1beta.OwnerType(0)

	_ = taskv1alpha.Task(0)
)

// Validate checks the field values on LivenessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LivenessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LivenessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LivenessRequestMultiError, or nil if none found.
func (m *LivenessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LivenessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.HealthCheckRequest != nil {

		if all {
			switch v := interface{}(m.GetHealthCheckRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LivenessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LivenessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHealthCheckRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LivenessRequestValidationError{
					field:  "HealthCheckRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LivenessRequestMultiError(errors)
	}

	return nil
}

// LivenessRequestMultiError is an error wrapping multiple validation errors
// returned by LivenessRequest.ValidateAll() if the designated constraints
// aren't met.
type LivenessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LivenessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LivenessRequestMultiError) AllErrors() []error { return m }

// LivenessRequestValidationError is the validation error returned by
// LivenessRequest.Validate if the designated constraints aren't met.
type LivenessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LivenessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LivenessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LivenessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LivenessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LivenessRequestValidationError) ErrorName() string { return "LivenessRequestValidationError" }

// Error satisfies the builtin error interface
func (e LivenessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLivenessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LivenessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LivenessRequestValidationError{}

// Validate checks the field values on LivenessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LivenessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LivenessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LivenessResponseMultiError, or nil if none found.
func (m *LivenessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LivenessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHealthCheckResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LivenessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LivenessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthCheckResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LivenessResponseValidationError{
				field:  "HealthCheckResponse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LivenessResponseMultiError(errors)
	}

	return nil
}

// LivenessResponseMultiError is an error wrapping multiple validation errors
// returned by LivenessResponse.ValidateAll() if the designated constraints
// aren't met.
type LivenessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LivenessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LivenessResponseMultiError) AllErrors() []error { return m }

// LivenessResponseValidationError is the validation error returned by
// LivenessResponse.Validate if the designated constraints aren't met.
type LivenessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LivenessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LivenessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LivenessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LivenessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LivenessResponseValidationError) ErrorName() string { return "LivenessResponseValidationError" }

// Error satisfies the builtin error interface
func (e LivenessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLivenessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LivenessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LivenessResponseValidationError{}

// Validate checks the field values on ReadinessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessRequestMultiError, or nil if none found.
func (m *ReadinessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.HealthCheckRequest != nil {

		if all {
			switch v := interface{}(m.GetHealthCheckRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadinessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadinessRequestValidationError{
						field:  "HealthCheckRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHealthCheckRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadinessRequestValidationError{
					field:  "HealthCheckRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadinessRequestMultiError(errors)
	}

	return nil
}

// ReadinessRequestMultiError is an error wrapping multiple validation errors
// returned by ReadinessRequest.ValidateAll() if the designated constraints
// aren't met.
type ReadinessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessRequestMultiError) AllErrors() []error { return m }

// ReadinessRequestValidationError is the validation error returned by
// ReadinessRequest.Validate if the designated constraints aren't met.
type ReadinessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessRequestValidationError) ErrorName() string { return "ReadinessRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReadinessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessRequestValidationError{}

// Validate checks the field values on ReadinessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadinessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadinessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadinessResponseMultiError, or nil if none found.
func (m *ReadinessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadinessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHealthCheckResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadinessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadinessResponseValidationError{
					field:  "HealthCheckResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthCheckResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadinessResponseValidationError{
				field:  "HealthCheckResponse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadinessResponseMultiError(errors)
	}

	return nil
}

// ReadinessResponseMultiError is an error wrapping multiple validation errors
// returned by ReadinessResponse.ValidateAll() if the designated constraints
// aren't met.
type ReadinessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadinessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadinessResponseMultiError) AllErrors() []error { return m }

// ReadinessResponseValidationError is the validation error returned by
// ReadinessResponse.Validate if the designated constraints aren't met.
type ReadinessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadinessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadinessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadinessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadinessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadinessResponseValidationError) ErrorName() string {
	return "ReadinessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadinessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadinessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadinessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadinessResponseValidationError{}

// Validate checks the field values on Session with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Session) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Session with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SessionMultiError, or nil if none found.
func (m *Session) ValidateAll() error {
	return m.validate(true)
}

func (m *Session) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Service

	// no validation rules for Edition

	// no validation rules for Version

	// no validation rules for Arch

	// no validation rules for Os

	// no validation rules for Uptime

	if all {
		switch v := interface{}(m.GetReportTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "ReportTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Token

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OwnerUid

	if len(errors) > 0 {
		return SessionMultiError(errors)
	}

	return nil
}

// SessionMultiError is an error wrapping multiple validation errors returned
// by Session.ValidateAll() if the designated constraints aren't met.
type SessionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionMultiError) AllErrors() []error { return m }

// SessionValidationError is the validation error returned by Session.Validate
// if the designated constraints aren't met.
type SessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionValidationError) ErrorName() string { return "SessionValidationError" }

// Error satisfies the builtin error interface
func (e SessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionValidationError{}

// Validate checks the field values on MgmtUsageData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MgmtUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MgmtUsageData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MgmtUsageDataMultiError, or
// nil if none found.
func (m *MgmtUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *MgmtUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MgmtUsageDataValidationError{
						field:  fmt.Sprintf("UserUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MgmtUsageDataValidationError{
						field:  fmt.Sprintf("UserUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MgmtUsageDataValidationError{
					field:  fmt.Sprintf("UserUsages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOrgUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MgmtUsageDataValidationError{
						field:  fmt.Sprintf("OrgUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MgmtUsageDataValidationError{
						field:  fmt.Sprintf("OrgUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MgmtUsageDataValidationError{
					field:  fmt.Sprintf("OrgUsages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MgmtUsageDataMultiError(errors)
	}

	return nil
}

// MgmtUsageDataMultiError is an error wrapping multiple validation errors
// returned by MgmtUsageData.ValidateAll() if the designated constraints
// aren't met.
type MgmtUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MgmtUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MgmtUsageDataMultiError) AllErrors() []error { return m }

// MgmtUsageDataValidationError is the validation error returned by
// MgmtUsageData.Validate if the designated constraints aren't met.
type MgmtUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MgmtUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MgmtUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MgmtUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MgmtUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MgmtUsageDataValidationError) ErrorName() string { return "MgmtUsageDataValidationError" }

// Error satisfies the builtin error interface
func (e MgmtUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMgmtUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MgmtUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MgmtUsageDataValidationError{}

// Validate checks the field values on ConnectorUsageData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectorUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorUsageData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectorUsageDataMultiError, or nil if none found.
func (m *ConnectorUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectorUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectorUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectorUsageDataValidationError{
					field:  fmt.Sprintf("Usages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConnectorUsageDataMultiError(errors)
	}

	return nil
}

// ConnectorUsageDataMultiError is an error wrapping multiple validation errors
// returned by ConnectorUsageData.ValidateAll() if the designated constraints
// aren't met.
type ConnectorUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorUsageDataMultiError) AllErrors() []error { return m }

// ConnectorUsageDataValidationError is the validation error returned by
// ConnectorUsageData.Validate if the designated constraints aren't met.
type ConnectorUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorUsageDataValidationError) ErrorName() string {
	return "ConnectorUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectorUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorUsageDataValidationError{}

// Validate checks the field values on ModelUsageData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelUsageData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelUsageDataMultiError,
// or nil if none found.
func (m *ModelUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelUsageDataValidationError{
					field:  fmt.Sprintf("Usages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ModelUsageDataMultiError(errors)
	}

	return nil
}

// ModelUsageDataMultiError is an error wrapping multiple validation errors
// returned by ModelUsageData.ValidateAll() if the designated constraints
// aren't met.
type ModelUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelUsageDataMultiError) AllErrors() []error { return m }

// ModelUsageDataValidationError is the validation error returned by
// ModelUsageData.Validate if the designated constraints aren't met.
type ModelUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelUsageDataValidationError) ErrorName() string { return "ModelUsageDataValidationError" }

// Error satisfies the builtin error interface
func (e ModelUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelUsageDataValidationError{}

// Validate checks the field values on PipelineUsageData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineUsageData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineUsageDataMultiError, or nil if none found.
func (m *PipelineUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineUsageDataValidationError{
					field:  fmt.Sprintf("Usages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PipelineUsageDataMultiError(errors)
	}

	return nil
}

// PipelineUsageDataMultiError is an error wrapping multiple validation errors
// returned by PipelineUsageData.ValidateAll() if the designated constraints
// aren't met.
type PipelineUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineUsageDataMultiError) AllErrors() []error { return m }

// PipelineUsageDataValidationError is the validation error returned by
// PipelineUsageData.Validate if the designated constraints aren't met.
type PipelineUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineUsageDataValidationError) ErrorName() string {
	return "PipelineUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineUsageDataValidationError{}

// Validate checks the field values on ArtifactUsageData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ArtifactUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArtifactUsageData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArtifactUsageDataMultiError, or nil if none found.
func (m *ArtifactUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *ArtifactUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ArtifactUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ArtifactUsageDataValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ArtifactUsageDataValidationError{
					field:  fmt.Sprintf("Usages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ArtifactUsageDataMultiError(errors)
	}

	return nil
}

// ArtifactUsageDataMultiError is an error wrapping multiple validation errors
// returned by ArtifactUsageData.ValidateAll() if the designated constraints
// aren't met.
type ArtifactUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArtifactUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArtifactUsageDataMultiError) AllErrors() []error { return m }

// ArtifactUsageDataValidationError is the validation error returned by
// ArtifactUsageData.Validate if the designated constraints aren't met.
type ArtifactUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArtifactUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArtifactUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArtifactUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArtifactUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArtifactUsageDataValidationError) ErrorName() string {
	return "ArtifactUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e ArtifactUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArtifactUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArtifactUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArtifactUsageDataValidationError{}

// Validate checks the field values on SessionReport with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SessionReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SessionReportMultiError, or
// nil if none found.
func (m *SessionReport) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionUid

	// no validation rules for Token

	// no validation rules for Pow

	if all {
		switch v := interface{}(m.GetSession()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionReportValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionReportValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSession()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionReportValidationError{
				field:  "Session",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.UsageData.(type) {
	case *SessionReport_MgmtUsageData:
		if v == nil {
			err := SessionReportValidationError{
				field:  "UsageData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMgmtUsageData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "MgmtUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "MgmtUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMgmtUsageData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionReportValidationError{
					field:  "MgmtUsageData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SessionReport_ConnectorUsageData:
		if v == nil {
			err := SessionReportValidationError{
				field:  "UsageData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnectorUsageData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "ConnectorUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "ConnectorUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnectorUsageData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionReportValidationError{
					field:  "ConnectorUsageData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SessionReport_ModelUsageData:
		if v == nil {
			err := SessionReportValidationError{
				field:  "UsageData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetModelUsageData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "ModelUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "ModelUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetModelUsageData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionReportValidationError{
					field:  "ModelUsageData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SessionReport_PipelineUsageData:
		if v == nil {
			err := SessionReportValidationError{
				field:  "UsageData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPipelineUsageData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "PipelineUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "PipelineUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPipelineUsageData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionReportValidationError{
					field:  "PipelineUsageData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SessionReport_ArtifactUsageData:
		if v == nil {
			err := SessionReportValidationError{
				field:  "UsageData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetArtifactUsageData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "ArtifactUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SessionReportValidationError{
						field:  "ArtifactUsageData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetArtifactUsageData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SessionReportValidationError{
					field:  "ArtifactUsageData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SessionReportMultiError(errors)
	}

	return nil
}

// SessionReportMultiError is an error wrapping multiple validation errors
// returned by SessionReport.ValidateAll() if the designated constraints
// aren't met.
type SessionReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionReportMultiError) AllErrors() []error { return m }

// SessionReportValidationError is the validation error returned by
// SessionReport.Validate if the designated constraints aren't met.
type SessionReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionReportValidationError) ErrorName() string { return "SessionReportValidationError" }

// Error satisfies the builtin error interface
func (e SessionReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionReportValidationError{}

// Validate checks the field values on CreateSessionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSessionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSessionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSessionRequestMultiError, or nil if none found.
func (m *CreateSessionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSessionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSession()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSessionRequestValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSessionRequestValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSession()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSessionRequestValidationError{
				field:  "Session",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSessionRequestMultiError(errors)
	}

	return nil
}

// CreateSessionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSessionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSessionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSessionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSessionRequestMultiError) AllErrors() []error { return m }

// CreateSessionRequestValidationError is the validation error returned by
// CreateSessionRequest.Validate if the designated constraints aren't met.
type CreateSessionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSessionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSessionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSessionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSessionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSessionRequestValidationError) ErrorName() string {
	return "CreateSessionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSessionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSessionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSessionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSessionRequestValidationError{}

// Validate checks the field values on CreateSessionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSessionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSessionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSessionResponseMultiError, or nil if none found.
func (m *CreateSessionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSessionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSession()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSessionResponseValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSessionResponseValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSession()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSessionResponseValidationError{
				field:  "Session",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSessionResponseMultiError(errors)
	}

	return nil
}

// CreateSessionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSessionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSessionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSessionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSessionResponseMultiError) AllErrors() []error { return m }

// CreateSessionResponseValidationError is the validation error returned by
// CreateSessionResponse.Validate if the designated constraints aren't met.
type CreateSessionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSessionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSessionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSessionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSessionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSessionResponseValidationError) ErrorName() string {
	return "CreateSessionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSessionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSessionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSessionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSessionResponseValidationError{}

// Validate checks the field values on SendSessionReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendSessionReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendSessionReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendSessionReportRequestMultiError, or nil if none found.
func (m *SendSessionReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendSessionReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReport()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendSessionReportRequestValidationError{
					field:  "Report",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendSessionReportRequestValidationError{
					field:  "Report",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReport()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendSessionReportRequestValidationError{
				field:  "Report",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendSessionReportRequestMultiError(errors)
	}

	return nil
}

// SendSessionReportRequestMultiError is an error wrapping multiple validation
// errors returned by SendSessionReportRequest.ValidateAll() if the designated
// constraints aren't met.
type SendSessionReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendSessionReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendSessionReportRequestMultiError) AllErrors() []error { return m }

// SendSessionReportRequestValidationError is the validation error returned by
// SendSessionReportRequest.Validate if the designated constraints aren't met.
type SendSessionReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendSessionReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendSessionReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendSessionReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendSessionReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendSessionReportRequestValidationError) ErrorName() string {
	return "SendSessionReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendSessionReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendSessionReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendSessionReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendSessionReportRequestValidationError{}

// Validate checks the field values on SendSessionReportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendSessionReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendSessionReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendSessionReportResponseMultiError, or nil if none found.
func (m *SendSessionReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SendSessionReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SendSessionReportResponseMultiError(errors)
	}

	return nil
}

// SendSessionReportResponseMultiError is an error wrapping multiple validation
// errors returned by SendSessionReportResponse.ValidateAll() if the
// designated constraints aren't met.
type SendSessionReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendSessionReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendSessionReportResponseMultiError) AllErrors() []error { return m }

// SendSessionReportResponseValidationError is the validation error returned by
// SendSessionReportResponse.Validate if the designated constraints aren't met.
type SendSessionReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendSessionReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendSessionReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendSessionReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendSessionReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendSessionReportResponseValidationError) ErrorName() string {
	return "SendSessionReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SendSessionReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendSessionReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendSessionReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendSessionReportResponseValidationError{}

// Validate checks the field values on ConnectorUsageData_UserUsageData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ConnectorUsageData_UserUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorUsageData_UserUsageData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ConnectorUsageData_UserUsageDataMultiError, or nil if none found.
func (m *ConnectorUsageData_UserUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorUsageData_UserUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUid

	for idx, item := range m.GetConnectorExecuteData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectorUsageData_UserUsageDataValidationError{
						field:  fmt.Sprintf("ConnectorExecuteData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectorUsageData_UserUsageDataValidationError{
						field:  fmt.Sprintf("ConnectorExecuteData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectorUsageData_UserUsageDataValidationError{
					field:  fmt.Sprintf("ConnectorExecuteData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OwnerType

	if len(errors) > 0 {
		return ConnectorUsageData_UserUsageDataMultiError(errors)
	}

	return nil
}

// ConnectorUsageData_UserUsageDataMultiError is an error wrapping multiple
// validation errors returned by
// ConnectorUsageData_UserUsageData.ValidateAll() if the designated
// constraints aren't met.
type ConnectorUsageData_UserUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorUsageData_UserUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorUsageData_UserUsageDataMultiError) AllErrors() []error { return m }

// ConnectorUsageData_UserUsageDataValidationError is the validation error
// returned by ConnectorUsageData_UserUsageData.Validate if the designated
// constraints aren't met.
type ConnectorUsageData_UserUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorUsageData_UserUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorUsageData_UserUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorUsageData_UserUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorUsageData_UserUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorUsageData_UserUsageDataValidationError) ErrorName() string {
	return "ConnectorUsageData_UserUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectorUsageData_UserUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorUsageData_UserUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorUsageData_UserUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorUsageData_UserUsageDataValidationError{}

// Validate checks the field values on
// ConnectorUsageData_UserUsageData_ConnectorExecuteData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectorUsageData_UserUsageData_ConnectorExecuteData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ConnectorUsageData_UserUsageData_ConnectorExecuteData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectorUsageData_UserUsageData_ConnectorExecuteDataMultiError, or nil if
// none found.
func (m *ConnectorUsageData_UserUsageData_ConnectorExecuteData) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorUsageData_UserUsageData_ConnectorExecuteData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConnectorUid

	// no validation rules for ExecuteUid

	if all {
		switch v := interface{}(m.GetExecuteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError{
					field:  "ExecuteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError{
					field:  "ExecuteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecuteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError{
				field:  "ExecuteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConnectorDefinitionUid

	// no validation rules for Status

	// no validation rules for UserUid

	// no validation rules for UserType

	if len(errors) > 0 {
		return ConnectorUsageData_UserUsageData_ConnectorExecuteDataMultiError(errors)
	}

	return nil
}

// ConnectorUsageData_UserUsageData_ConnectorExecuteDataMultiError is an error
// wrapping multiple validation errors returned by
// ConnectorUsageData_UserUsageData_ConnectorExecuteData.ValidateAll() if the
// designated constraints aren't met.
type ConnectorUsageData_UserUsageData_ConnectorExecuteDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorUsageData_UserUsageData_ConnectorExecuteDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorUsageData_UserUsageData_ConnectorExecuteDataMultiError) AllErrors() []error {
	return m
}

// ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError is the
// validation error returned by
// ConnectorUsageData_UserUsageData_ConnectorExecuteData.Validate if the
// designated constraints aren't met.
type ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError) ErrorName() string {
	return "ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorUsageData_UserUsageData_ConnectorExecuteData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorUsageData_UserUsageData_ConnectorExecuteDataValidationError{}

// Validate checks the field values on ModelUsageData_UserUsageData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelUsageData_UserUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelUsageData_UserUsageData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelUsageData_UserUsageDataMultiError, or nil if none found.
func (m *ModelUsageData_UserUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelUsageData_UserUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUid

	for idx, item := range m.GetModelTriggerData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelUsageData_UserUsageDataValidationError{
						field:  fmt.Sprintf("ModelTriggerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelUsageData_UserUsageDataValidationError{
						field:  fmt.Sprintf("ModelTriggerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelUsageData_UserUsageDataValidationError{
					field:  fmt.Sprintf("ModelTriggerData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OwnerType

	if len(errors) > 0 {
		return ModelUsageData_UserUsageDataMultiError(errors)
	}

	return nil
}

// ModelUsageData_UserUsageDataMultiError is an error wrapping multiple
// validation errors returned by ModelUsageData_UserUsageData.ValidateAll() if
// the designated constraints aren't met.
type ModelUsageData_UserUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelUsageData_UserUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelUsageData_UserUsageDataMultiError) AllErrors() []error { return m }

// ModelUsageData_UserUsageDataValidationError is the validation error returned
// by ModelUsageData_UserUsageData.Validate if the designated constraints
// aren't met.
type ModelUsageData_UserUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelUsageData_UserUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelUsageData_UserUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelUsageData_UserUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelUsageData_UserUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelUsageData_UserUsageDataValidationError) ErrorName() string {
	return "ModelUsageData_UserUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e ModelUsageData_UserUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelUsageData_UserUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelUsageData_UserUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelUsageData_UserUsageDataValidationError{}

// Validate checks the field values on
// ModelUsageData_UserUsageData_ModelTriggerData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelUsageData_UserUsageData_ModelTriggerData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelUsageData_UserUsageData_ModelTriggerData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ModelUsageData_UserUsageData_ModelTriggerDataMultiError, or nil if none found.
func (m *ModelUsageData_UserUsageData_ModelTriggerData) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelUsageData_UserUsageData_ModelTriggerData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ModelUid

	// no validation rules for TriggerUid

	if all {
		switch v := interface{}(m.GetTriggerTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelUsageData_UserUsageData_ModelTriggerDataValidationError{
					field:  "TriggerTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelUsageData_UserUsageData_ModelTriggerDataValidationError{
					field:  "TriggerTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTriggerTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelUsageData_UserUsageData_ModelTriggerDataValidationError{
				field:  "TriggerTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ModelDefinitionUid

	// no validation rules for ModelTask

	// no validation rules for Status

	// no validation rules for UserUid

	// no validation rules for UserType

	if len(errors) > 0 {
		return ModelUsageData_UserUsageData_ModelTriggerDataMultiError(errors)
	}

	return nil
}

// ModelUsageData_UserUsageData_ModelTriggerDataMultiError is an error wrapping
// multiple validation errors returned by
// ModelUsageData_UserUsageData_ModelTriggerData.ValidateAll() if the
// designated constraints aren't met.
type ModelUsageData_UserUsageData_ModelTriggerDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelUsageData_UserUsageData_ModelTriggerDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelUsageData_UserUsageData_ModelTriggerDataMultiError) AllErrors() []error { return m }

// ModelUsageData_UserUsageData_ModelTriggerDataValidationError is the
// validation error returned by
// ModelUsageData_UserUsageData_ModelTriggerData.Validate if the designated
// constraints aren't met.
type ModelUsageData_UserUsageData_ModelTriggerDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelUsageData_UserUsageData_ModelTriggerDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelUsageData_UserUsageData_ModelTriggerDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ModelUsageData_UserUsageData_ModelTriggerDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelUsageData_UserUsageData_ModelTriggerDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelUsageData_UserUsageData_ModelTriggerDataValidationError) ErrorName() string {
	return "ModelUsageData_UserUsageData_ModelTriggerDataValidationError"
}

// Error satisfies the builtin error interface
func (e ModelUsageData_UserUsageData_ModelTriggerDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelUsageData_UserUsageData_ModelTriggerData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelUsageData_UserUsageData_ModelTriggerDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelUsageData_UserUsageData_ModelTriggerDataValidationError{}

// Validate checks the field values on PipelineUsageData_UserUsageData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineUsageData_UserUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineUsageData_UserUsageData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PipelineUsageData_UserUsageDataMultiError, or nil if none found.
func (m *PipelineUsageData_UserUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineUsageData_UserUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUid

	for idx, item := range m.GetPipelineTriggerData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineUsageData_UserUsageDataValidationError{
						field:  fmt.Sprintf("PipelineTriggerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineUsageData_UserUsageDataValidationError{
						field:  fmt.Sprintf("PipelineTriggerData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineUsageData_UserUsageDataValidationError{
					field:  fmt.Sprintf("PipelineTriggerData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OwnerType

	if len(errors) > 0 {
		return PipelineUsageData_UserUsageDataMultiError(errors)
	}

	return nil
}

// PipelineUsageData_UserUsageDataMultiError is an error wrapping multiple
// validation errors returned by PipelineUsageData_UserUsageData.ValidateAll()
// if the designated constraints aren't met.
type PipelineUsageData_UserUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineUsageData_UserUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineUsageData_UserUsageDataMultiError) AllErrors() []error { return m }

// PipelineUsageData_UserUsageDataValidationError is the validation error
// returned by PipelineUsageData_UserUsageData.Validate if the designated
// constraints aren't met.
type PipelineUsageData_UserUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineUsageData_UserUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineUsageData_UserUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineUsageData_UserUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineUsageData_UserUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineUsageData_UserUsageDataValidationError) ErrorName() string {
	return "PipelineUsageData_UserUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineUsageData_UserUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineUsageData_UserUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineUsageData_UserUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineUsageData_UserUsageDataValidationError{}

// Validate checks the field values on
// PipelineUsageData_UserUsageData_PipelineTriggerData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineUsageData_UserUsageData_PipelineTriggerData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PipelineUsageData_UserUsageData_PipelineTriggerData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// PipelineUsageData_UserUsageData_PipelineTriggerDataMultiError, or nil if
// none found.
func (m *PipelineUsageData_UserUsageData_PipelineTriggerData) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineUsageData_UserUsageData_PipelineTriggerData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PipelineUid

	// no validation rules for TriggerUid

	if all {
		switch v := interface{}(m.GetTriggerTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError{
					field:  "TriggerTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError{
					field:  "TriggerTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTriggerTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError{
				field:  "TriggerTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TriggerMode

	// no validation rules for Status

	// no validation rules for PipelineReleaseId

	// no validation rules for PipelineReleaseUid

	// no validation rules for UserUid

	// no validation rules for UserType

	// no validation rules for PipelineId

	if len(errors) > 0 {
		return PipelineUsageData_UserUsageData_PipelineTriggerDataMultiError(errors)
	}

	return nil
}

// PipelineUsageData_UserUsageData_PipelineTriggerDataMultiError is an error
// wrapping multiple validation errors returned by
// PipelineUsageData_UserUsageData_PipelineTriggerData.ValidateAll() if the
// designated constraints aren't met.
type PipelineUsageData_UserUsageData_PipelineTriggerDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineUsageData_UserUsageData_PipelineTriggerDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineUsageData_UserUsageData_PipelineTriggerDataMultiError) AllErrors() []error { return m }

// PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError is the
// validation error returned by
// PipelineUsageData_UserUsageData_PipelineTriggerData.Validate if the
// designated constraints aren't met.
type PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError) ErrorName() string {
	return "PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineUsageData_UserUsageData_PipelineTriggerData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineUsageData_UserUsageData_PipelineTriggerDataValidationError{}

// Validate checks the field values on ArtifactUsageData_UserUsageData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ArtifactUsageData_UserUsageData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArtifactUsageData_UserUsageData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ArtifactUsageData_UserUsageDataMultiError, or nil if none found.
func (m *ArtifactUsageData_UserUsageData) ValidateAll() error {
	return m.validate(true)
}

func (m *ArtifactUsageData_UserUsageData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUid

	// no validation rules for OwnerType

	if len(errors) > 0 {
		return ArtifactUsageData_UserUsageDataMultiError(errors)
	}

	return nil
}

// ArtifactUsageData_UserUsageDataMultiError is an error wrapping multiple
// validation errors returned by ArtifactUsageData_UserUsageData.ValidateAll()
// if the designated constraints aren't met.
type ArtifactUsageData_UserUsageDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArtifactUsageData_UserUsageDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArtifactUsageData_UserUsageDataMultiError) AllErrors() []error { return m }

// ArtifactUsageData_UserUsageDataValidationError is the validation error
// returned by ArtifactUsageData_UserUsageData.Validate if the designated
// constraints aren't met.
type ArtifactUsageData_UserUsageDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArtifactUsageData_UserUsageDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArtifactUsageData_UserUsageDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArtifactUsageData_UserUsageDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArtifactUsageData_UserUsageDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArtifactUsageData_UserUsageDataValidationError) ErrorName() string {
	return "ArtifactUsageData_UserUsageDataValidationError"
}

// Error satisfies the builtin error interface
func (e ArtifactUsageData_UserUsageDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArtifactUsageData_UserUsageData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArtifactUsageData_UserUsageDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArtifactUsageData_UserUsageDataValidationError{}
